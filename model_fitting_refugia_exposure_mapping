## Script name: SDM model fitting pipeline using test data sets for Southeastern Canada
##
## Purpose of script: To build a pipeline for modeling large amounts of species occurrence data, using parallel clusters
##
## Source: Yisa Ginath Yuh, adapted from scripts produced for the prairie region by James Paterson
## Email: gyisa@uottawa.ca

##--------------------------------------------------------------------------------------

library(dismo) # for maxent modelling
library(raster) # for raster creation, manipulation, and analysis
library(dplyr) # tidy data
library(magrittr) # for streamlining manipulated data and making codes easily readable with the pipe operator
library(rgdal) # for handling spatial data in different formats and facilitating projection
library(sp) # for handling spatial data, especially vector layers
library(maxnet) # for MaxEnt modeliing
library(ggplot2) # plotting results
library(rnaturalearth)# for handling background map data
library(rnaturalearthdata) # for handling background map data
Sys.setenv("PROJ_NETWORK" = "ON")
library(sf)# for handling spatial data in different formats and facilitating projection
library(terra) #for raster creation, manipulation, and analysis
library(blockCV)# for spatial cross-validation with presence-absence data
library(spatialEco)# provide importnt functions for manipulating, querying, and modeling spatial datasets in ecology
library(pROC)

##--------------------------------------------------------------------------------------

# The MaxEnt model fitting requires java, and it is very imperative ti allocate a maximum memory space with java, so as to reduce memory issues when running java operations (e.g., rjava).
# Ensure to set java heap space based on your computer RAM.
# Here, I am setting my Java heap space to 8GB. users can modify to different GB limits
options(java.parameters = '-Xmx8g') 

#par(mfrow = c(1, 1))


###-------------- Loading, cleaning, and projecting data-----------------------

# 1. I start my analysis by loading and stacking my spatial environmental variables using a function

# Load rasters for environmental data

# load historical climate data
MAT <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_MAT.tif")
MAT
MAP <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_MAP.tif")
DD_18 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_DD_18.tif")
DD18 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_DD18.tif")
NFFD <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_NFFD.tif")
EMT <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_EMT.tif")
EXT <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_EXT.tif")
Tave_wt <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_Tav_wt.tif")
Tave_sm <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_Tav_sm.tif")
Tave_sp <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_Tav_sp.tif")
Tave_at <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_Tav_at.tif")
PPT_wt <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_PPT_wt.tif")
PPT_sm <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_PPT_sm.tif")
PPT_sp <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_PPT_sp.tif")
PPT_at <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_PPT_at.tif")
slope <- raster("F:/Uillinois_data/analysis/habitat_suitability/slope.tif")
elevation <- raster("F:/Uillinois_data/analysis/habitat_suitability/elevation.tif")


# Read Bioclim variables
MAT_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_MAT.tif")
MAT_2020_ssp126
MAP_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_MAP.tif")
DD_18_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_DD_18.tif")
DD18_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_DD18.tif")
NFFD_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_NFFD.tif")
EMT_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_EMT.tif")
EXT_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_EXT.tif")
Tave_wt_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_Tav_wt.tif")
Tave_sm_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_Tav_sm.tif")
Tave_sp_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_Tav_sp.tif")
Tave_at_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_Tav_at.tif")
PPT_wt_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_PPT_wt.tif")
PPT_sm_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_PPT_sm.tif")
PPT_sp_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_PPT_sp.tif")
PPT_at_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_PPT_at.tif")

# SSP245

# Read Bioclim variables
MAT_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_MAT.tif")
MAT_2020_ssp245
MAP_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_MAP.tif")
DD_18_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_DD_18.tif")
DD18_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_DD18.tif")
NFFD_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_NFFD.tif")
EMT_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_EMT.tif")
EXT_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_EXT.tif")
Tave_wt_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_Tav_wt.tif")
Tave_sm_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_Tav_sm.tif")
Tave_sp_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_Tav_sp.tif")
Tave_at_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_Tav_at.tif")
PPT_wt_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_PPT_wt.tif")
PPT_sm_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_PPT_sm.tif")
PPT_sp_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_PPT_sp.tif")
PPT_at_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_PPT_at.tif")

# SSP585

# Read Bioclim variables
MAT_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_MAT.tif")
MAT_2020_ssp585
MAP_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_MAP.tif")
DD_18_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_DD_18.tif")
DD18_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_DD18.tif")
NFFD_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_NFFD.tif")
EMT_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_EMT.tif")
EXT_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_EXT.tif")
Tave_wt_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_Tav_wt.tif")
Tave_sm_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_Tav_sm.tif")
Tave_sp_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_Tav_sp.tif")
Tave_at_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_Tav_at.tif")
PPT_wt_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_PPT_wt.tif")
PPT_sm_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_PPT_sm.tif")
PPT_sp_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_PPT_sp.tif")
PPT_at_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_PPT_at.tif")

# SSP126

# Read Bioclim variables
MAT_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_MAT.tif")
MAT_2050_ssp126
MAP_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_MAP.tif")
DD_18_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_DD_18.tif")
DD18_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_DD18.tif")
NFFD_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_NFFD.tif")
EMT_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_EMT.tif")
EXT_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_EXT.tif")
Tave_wt_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_Tav_wt.tif")
Tave_sm_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_Tav_sm.tif")
Tave_sp_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_Tav_sp.tif")
Tave_at_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_Tav_at.tif")
PPT_wt_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_PPT_wt.tif")
PPT_sm_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_PPT_sm.tif")
PPT_sp_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_PPT_sp.tif")
PPT_at_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_PPT_at.tif")

# SSP245

# Read Bioclim variables
MAT_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_MAT.tif")
MAT_2050_ssp245
MAP_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_MAP.tif")
DD_18_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_DD_18.tif")
DD18_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_DD18.tif")
NFFD_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_NFFD.tif")
EMT_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_EMT.tif")
EXT_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_EXT.tif")
Tave_wt_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_Tav_wt.tif")
Tave_sm_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_Tav_sm.tif")
Tave_sp_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_Tav_sp.tif")
Tave_at_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_Tav_at.tif")
PPT_wt_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_PPT_wt.tif")
PPT_sm_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_PPT_sm.tif")
PPT_sp_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_PPT_sp.tif")
PPT_at_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_PPT_at.tif")

# SSP585

# Read Bioclim variables
MAT_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_MAT.tif")
MAT_2050_ssp585
MAP_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_MAP.tif")
DD_18_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_DD_18.tif")
DD18_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_DD18.tif")
NFFD_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_NFFD.tif")
EMT_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_EMT.tif")
EXT_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_EXT.tif")
Tave_wt_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_Tav_wt.tif")
Tave_sm_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_Tav_sm.tif")
Tave_sp_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_Tav_sp.tif")
Tave_at_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_Tav_at.tif")
PPT_wt_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_PPT_wt.tif")
PPT_sm_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_PPT_sm.tif")
PPT_sp_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_PPT_sp.tif")
PPT_at_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_PPT_at.tif")

# Repeat for 2080

# SSP126

# Read Bioclim variables
MAT_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_MAT.tif")
MAT_2080_ssp126
MAP_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_MAP.tif")
DD_18_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_DD_18.tif")
DD18_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_DD18.tif")
NFFD_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_NFFD.tif")
EMT_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_EMT.tif")
EXT_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_EXT.tif")
Tave_wt_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_Tav_wt.tif")
Tave_sm_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_Tav_sm.tif")
Tave_sp_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_Tav_sp.tif")
Tave_at_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_Tav_at.tif")
PPT_wt_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_PPT_wt.tif")
PPT_sm_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_PPT_sm.tif")
PPT_sp_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_PPT_sp.tif")
PPT_at_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_PPT_at.tif")

# SSP245

# Read Bioclim variables
MAT_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_MAT.tif")
MAT_2080_ssp245
MAP_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_MAP.tif")
DD_18_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_DD_18.tif")
DD18_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_DD18.tif")
NFFD_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_NFFD.tif")
EMT_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_EMT.tif")
EXT_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_EXT.tif")
Tave_wt_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_Tav_wt.tif")
Tave_sm_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_Tav_sm.tif")
Tave_sp_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_Tav_sp.tif")
Tave_at_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_Tav_at.tif")
PPT_wt_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_PPT_wt.tif")
PPT_sm_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_PPT_sm.tif")
PPT_sp_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_PPT_sp.tif")
PPT_at_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_PPT_at.tif")

# SSP585

# Read Bioclim variables
MAT_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_MAT.tif")
MAT_2080_ssp585
MAP_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_MAP.tif")
DD_18_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_DD_18.tif")
DD18_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_DD18.tif")
NFFD_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_NFFD.tif")
EMT_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_EMT.tif")
EXT_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_EXT.tif")
Tave_wt_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_Tav_wt.tif")
Tave_sm_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_Tav_sm.tif")
Tave_sp_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_Tav_sp.tif")
Tave_at_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_Tav_at.tif")
PPT_wt_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_PPT_wt.tif")
PPT_sm_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_PPT_sm.tif")
PPT_sp_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_PPT_sp.tif")
PPT_at_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_PPT_at.tif")


# Load land cover data------------------------------
forest_hist <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/forest/suitability/forest_suitability_hist_updated.tif")
forest_hist
forest_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/forest/suitability/forest_suitability_2020_ssp126_updated.tif")
forest_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/forest/suitability/forest_suitability_2020_ssp245_updated.tif")
forest_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/forest/suitability/forest_suitability_2020_ssp585_updated.tif")
forest_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/forest/suitability/forest_suitability_2050_ssp126_updated.tif")
forest_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/forest/suitability/forest_suitability_2050_ssp245_updated.tif")
forest_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/forest/suitability/forest_suitability_2050_ssp585_updated.tif")
forest_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/forest/suitability/forest_suitability_2080_ssp126_updated.tif")
forest_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/forest/suitability/forest_suitability_2080_ssp245_updated.tif")
forest_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/forest/suitability/forest_suitability_2080_ssp585_updated.tif")

grassland_hist <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/grassland/suitability/grassland_suitability_hist_updated.tif")
grassland_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/grassland/suitability/grassland_suitability_2020_ssp126_updated.tif")
grassland_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/grassland/suitability/grassland_suitability_2020_ssp245_updated.tif")
grassland_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/grassland/suitability/grassland_suitability_2020_ssp585_updated.tif")
grassland_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/grassland/suitability/grassland_suitability_2050_ssp126_updated.tif")
grassland_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/grassland/suitability/grassland_suitability_2050_ssp245_updated.tif")
grassland_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/grassland/suitability/grassland_suitability_2050_ssp585_updated.tif")
grassland_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/grassland/suitability/grassland_suitability_2080_ssp126_updated.tif")
grassland_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/grassland/suitability/grassland_suitability_2080_ssp245_updated.tif")
grassland_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/grassland/suitability/grassland_suitability_2080_ssp585_updated.tif")

wetland_hist <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/wetland/suitability/wetland_suitability_hist_updated.tif")
wetland_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/wetland/suitability/wetland_suitability_2020_ssp126.tif")
wetland_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/wetland/suitability/wetland_suitability_2020_ssp245.tif")
wetland_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/wetland/suitability/wetland_suitability_2020_ssp585.tif")
wetland_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/wetland/suitability/wetland_suitability_2050_ssp126.tif")
wetland_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/wetland/suitability/wetland_suitability_2050_ssp245.tif")
wetland_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/wetland/suitability/wetland_suitability_2050_ssp585.tif")
wetland_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/wetland/suitability/wetland_suitability_2080_ssp126.tif")
wetland_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/wetland/suitability/wetland_suitability_2080_ssp245.tif")
wetland_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/wetland/suitability/wetland_suitability_2080_ssp585.tif")

cropland_hist <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/cropland/suitability/cropland_suitability_hist_updated.tif")
cropland_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/cropland/suitability/cropland_suitability_2020_ssp126_updated.tif")
cropland_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/cropland/suitability/cropland_suitability_2020_ssp245_updated.tif")
cropland_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/cropland/suitability/cropland_suitability_2020_ssp585_updated.tif")
cropland_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/cropland/suitability/cropland_suitability_2050_ssp126_updated.tif")
cropland_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/cropland/suitability/cropland_suitability_2050_ssp245_updated.tif")
cropland_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/cropland/suitability/cropland_suitability_2050_ssp585_updated.tif")
cropland_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/cropland/suitability/cropland_suitability_2080_ssp126.tif")
cropland_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/cropland/suitability/cropland_suitability_2080_ssp245_updated.tif")
cropland_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/cropland/suitability/cropland_suitability_2080_ssp585_updated.tif")

water_hist <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/water/suitability/water_suitability_hist_updated.tif")
water_2020_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/water/suitability/water_suitability_2020_ssp126_updated.tif")
water_2020_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/water/suitability/water_suitability_2020_ssp245_updated.tif")
water_2020_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/water/suitability/water_suitability_2020_ssp585_updated.tif")
water_2050_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/water/suitability/water_suitability_2050_ssp126_updated.tif")
water_2050_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/water/suitability/water_suitability_2050_ssp245_updated.tif")
water_2050_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/water/suitability/water_suitability_2050_ssp585_updated.tif")
water_2080_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/water/suitability/water_suitability_2080_ssp126_updated.tif")
water_2080_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/water/suitability/water_suitability_2080_ssp245_updated.tif")
water_2080_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/water/suitability/water_suitability_2080_ssp585_updated.tif")

urban_hist <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/urban/suitability/urban_suitability_hist.tif")

# resample land cover
water_r <- resample(water_hist, EMT, method = "ngb")
water_r_2020_ssp126 <- resample(water_2020_ssp126, EMT, method = "ngb")
water_r_2020_ssp245 <- resample(water_2020_ssp245, EMT, method = "ngb")
water_r_2020_ssp585 <- resample(water_2020_ssp585, EMT, method = "ngb")
water_r_2050_ssp126 <- resample(water_2050_ssp126, EMT, method = "ngb")
water_r_2050_ssp245 <- resample(water_2050_ssp245, EMT, method = "ngb")
water_r_2050_ssp585 <- resample(water_2050_ssp585, EMT, method = "ngb")
water_r_2080_ssp126 <- resample(water_2080_ssp126, EMT, method = "ngb")
water_r_2080_ssp245 <- resample(water_2080_ssp245, EMT, method = "ngb")
water_r_2080_ssp585 <- resample(water_2080_ssp585, EMT, method = "ngb")

forest_r <- resample(forest_hist, EMT, method = "ngb")
forest_r_2020_ssp126 <- resample(forest_2020_ssp126, EMT, method = "ngb")
forest_r_2020_ssp245 <- resample(forest_2020_ssp245, EMT, method = "ngb")
forest_r_2020_ssp585 <- resample(forest_2020_ssp585, EMT, method = "ngb")
forest_r_2050_ssp126 <- resample(forest_2050_ssp126, EMT, method = "ngb")
forest_r_2050_ssp245 <- resample(forest_2050_ssp245, EMT, method = "ngb")
forest_r_2050_ssp585 <- resample(forest_2050_ssp585, EMT, method = "ngb")
forest_r_2080_ssp126 <- resample(forest_2080_ssp126, EMT, method = "ngb")
forest_r_2080_ssp245 <- resample(forest_2080_ssp245, EMT, method = "ngb")
forest_r_2080_ssp585 <- resample(forest_2080_ssp585, EMT, method = "ngb")

wetland_r <- resample(wetland_hist, EMT, method = "ngb")
wetland_r_2020_ssp126 <- resample(wetland_2020_ssp126, EMT, method = "ngb")
wetland_r_2020_ssp245 <- resample(wetland_2020_ssp245, EMT, method = "ngb")
wetland_r_2020_ssp585 <- resample(wetland_2020_ssp585, EMT, method = "ngb")
wetland_r_2050_ssp126 <- resample(wetland_2050_ssp126, EMT, method = "ngb")
wetland_r_2050_ssp245 <- resample(wetland_2050_ssp245, EMT, method = "ngb")
wetland_r_2050_ssp585 <- resample(wetland_2050_ssp585, EMT, method = "ngb")
wetland_r_2080_ssp126 <- resample(wetland_2080_ssp126, EMT, method = "ngb")
wetland_r_2080_ssp245 <- resample(wetland_2080_ssp245, EMT, method = "ngb")
wetland_r_2080_ssp585 <- resample(wetland_2080_ssp585, EMT, method = "ngb")

cropland_r <- resample(cropland_hist, EMT, method = "ngb")
cropland_r_2020_ssp126 <- resample(cropland_2020_ssp126, EMT, method = "ngb")
cropland_r_2020_ssp245 <- resample(cropland_2020_ssp245, EMT, method = "ngb")
cropland_r_2020_ssp585 <- resample(cropland_2020_ssp585, EMT, method = "ngb")
cropland_r_2050_ssp126 <- resample(cropland_2050_ssp126, EMT, method = "ngb")
cropland_r_2050_ssp245 <- resample(cropland_2050_ssp245, EMT, method = "ngb")
cropland_r_2050_ssp585 <- resample(cropland_2050_ssp585, EMT, method = "ngb")
cropland_r_2080_ssp126 <- resample(cropland_2080_ssp126, EMT, method = "ngb")
cropland_r_2080_ssp245 <- resample(cropland_2080_ssp245, EMT, method = "ngb")
cropland_r_2080_ssp585 <- resample(cropland_2080_ssp585, EMT, method = "ngb")

grassland_r <- resample(grassland_hist, EMT, method = "ngb")
grassland_r_2020_ssp126 <- resample(grassland_2020_ssp126, EMT, method = "ngb")
grassland_r_2020_ssp245 <- resample(grassland_2020_ssp245, EMT, method = "ngb")
grassland_r_2020_ssp585 <- resample(grassland_2020_ssp585, EMT, method = "ngb")
grassland_r_2050_ssp126 <- resample(grassland_2050_ssp126, EMT, method = "ngb")
grassland_r_2050_ssp245 <- resample(grassland_2050_ssp245, EMT, method = "ngb")
grassland_r_2050_ssp585 <- resample(grassland_2050_ssp585, EMT, method = "ngb")
grassland_r_2080_ssp126 <- resample(grassland_2080_ssp126, EMT, method = "ngb")
grassland_r_2080_ssp245 <- resample(grassland_2080_ssp245, EMT, method = "ngb")
grassland_r_2080_ssp585 <- resample(grassland_2080_ssp585, EMT, method = "ngb")

urban_r <- resample(urban_hist, EMT, method = "ngb")
urban_r

# Use population density as a proxy to urban expansion
library("ncdf4")

pop_2020s_ssp126 <- raster("F:/Uottawa_data/SE_analysis/pop_density/raw_data/2611_worldpop_SSP1-RCP2.6_2011-02-01_2040-12-31_1year_mean.nc")
pop_2020s_ssp245 <- raster("F:/Uottawa_data/SE_analysis/pop_density/raw_data/2613_worldpop_SSP2-RCP4.5_2011-02-01_2040-12-31_1year_mean.nc")
pop_2020s_ssp585 <- raster("F:/Uottawa_data/SE_analysis/pop_density/raw_data/2614_worldpop_SSP5-RCP8_5_2011-01-01_2040-12-31_1year_mean.nc")

pop_2050s_ssp126 <- raster("F:/Uottawa_data/SE_analysis/pop_density/raw_data/2615_worldpop_SSP1-RCP2.6_2041-01-01_2070-12-31_1year_mean.nc")
pop_2050s_ssp245 <- raster("F:/Uottawa_data/SE_analysis/pop_density/raw_data/2616_worldpop_SSP2-RCP4.5_2041-01-01_2070-12-31_1year_mean.nc")
pop_2050s_ssp585 <- raster("F:/Uottawa_data/SE_analysis/pop_density/raw_data/2617_worldpop_SSP5-RCP8_5_2041-01-01_2070-12-31_1year_mean.nc")

pop_2080s_ssp126 <- raster("F:/Uottawa_data/SE_analysis/pop_density/raw_data/2618_worldpop_SSP1-RCP2.6_2071-01-01_2100-12-31_1year_mean.nc")
pop_2080s_ssp245 <- raster("F:/Uottawa_data/SE_analysis/pop_density/raw_data/2619_worldpop_SSP2-RCP4.5_2071-01-01_2100-12-31_1year_mean.nc")
pop_2080s_ssp585 <- raster("F:/Uottawa_data/SE_analysis/pop_density/raw_data/261a_worldpop_SSP5-RCP8_5_2071-01-01_2100-12-31_1year_mean.nc")


# Reproject the study area to pop density
study_area2 <- st_transform(study_area, crs = crs(pop_2020s_ssp126))

crop_and_mask_raster <- function(raster_layer, mask_shape) {
  cropped <- crop(raster_layer, mask_shape)
  masked <- mask(cropped, mask_shape)
  return(masked)
}

pop_2020s_ssp126_masked <- crop_and_mask_raster(pop_2020s_ssp126, study_area2)
pop_2020s_ssp245_masked <- crop_and_mask_raster(pop_2020s_ssp245, study_area2)
pop_2020s_ssp585_masked <- crop_and_mask_raster(pop_2020s_ssp585, study_area2)

pop_2050s_ssp126_masked <- crop_and_mask_raster(pop_2050s_ssp126, study_area2)
pop_2050s_ssp245_masked <- crop_and_mask_raster(pop_2050s_ssp245, study_area2)
pop_2050s_ssp585_masked <- crop_and_mask_raster(pop_2050s_ssp585, study_area2)

pop_2080s_ssp126_masked <- crop_and_mask_raster(pop_2080s_ssp126, study_area2)
pop_2080s_ssp245_masked <- crop_and_mask_raster(pop_2080s_ssp245, study_area2)
pop_2080s_ssp585_masked <- crop_and_mask_raster(pop_2080s_ssp585, study_area2)

plot(pop_2080s_ssp585_masked)

# Reproject population density to match CRS of study area
study_crs <- st_crs(study_area)$wkt
pop_2020_ssp126_project <- projectRaster(pop_2020s_ssp126_masked, crs = study_crs)
pop_2020_ssp245_project <- projectRaster(pop_2020s_ssp245_masked, crs = study_crs)
pop_2020_ssp585_project <- projectRaster(pop_2020s_ssp585_masked, crs = study_crs)

pop_2050_ssp126_project <- projectRaster(pop_2050s_ssp126_masked, crs = study_crs)
pop_2050_ssp245_project <- projectRaster(pop_2050s_ssp245_masked, crs = study_crs)
pop_2050_ssp585_project <- projectRaster(pop_2050s_ssp585_masked, crs = study_crs)

pop_2080_ssp126_project <- projectRaster(pop_2080s_ssp126_masked, crs = study_crs)
pop_2080_ssp245_project <- projectRaster(pop_2080s_ssp245_masked, crs = study_crs)
pop_2080_ssp585_project <- projectRaster(pop_2080s_ssp585_masked, crs = study_crs)

plot(pop_2020_ssp126_project)

#  Reproject, crop, and resample  to match the CRS and extent of climate data

#  2020s

pop_2020_ssp126_proj <- projectRaster(pop_2020_ssp126_project, crs = crs(EMT), method = "bilinear")
pop_2020_ssp126_crop <- crop(pop_2020_ssp126_proj, extent(EMT))
pop_2020_ssp126_resampled <- resample(pop_2020_ssp126_crop, EMT, method = "bilinear")
plot(pop_2020_ssp126_resampled)
writeRaster(pop_2020_ssp126_resampled, "F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_densitypop_2020_ssp126_aligned.tif", overwrite = TRUE)

pop_2020_ssp245_proj <- projectRaster(pop_2020_ssp245_project, crs = crs(EMT), method = "bilinear")
pop_2020_ssp245_crop <- crop(pop_2020_ssp245_proj, extent(EMT))
pop_2020_ssp245_resampled <- resample(pop_2020_ssp245_crop, EMT, method = "bilinear")
plot(pop_2020_ssp245_resampled)
pop_2020_ssp245_resampled
writeRaster(pop_2020_ssp245_resampled, "F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2020_ssp245_aligned.tif", overwrite = TRUE)

pop_2020_ssp585_proj <- projectRaster(pop_2020_ssp585_project, crs = crs(EMT), method = "bilinear")
pop_2020_ssp585_crop <- crop(pop_2020_ssp585_proj, extent(EMT))
pop_2020_ssp585_resampled <- resample(pop_2020_ssp585_crop, EMT, method = "bilinear")
plot(pop_2020_ssp585_resampled)
writeRaster(pop_2020_ssp585_resampled, "F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2020_ssp585_aligned.tif", overwrite = TRUE)


#  2050s

pop_2050_ssp126_proj <- projectRaster(pop_2050_ssp126_project, crs = crs(EMT), method = "bilinear")
pop_2050_ssp126_crop <- crop(pop_2050_ssp126_proj, extent(EMT))
pop_2050_ssp126_resampled <- resample(pop_2050_ssp126_crop, EMT, method = "bilinear")
plot(pop_2050_ssp126_resampled)
writeRaster(pop_2050_ssp126_resampled, "F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2050_ssp126_aligned.tif", overwrite = TRUE)

pop_2050_ssp245_proj <- projectRaster(pop_2050_ssp245_project, crs = crs(EMT), method = "bilinear")
pop_2050_ssp245_crop <- crop(pop_2050_ssp245_proj, extent(EMT))
pop_2050_ssp245_resampled <- resample(pop_2050_ssp245_crop, EMT, method = "bilinear")
plot(pop_2050_ssp245_resampled)
writeRaster(pop_2050_ssp245_resampled, "F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2050_ssp245_aligned.tif", overwrite = TRUE)

pop_2050_ssp585_proj <- projectRaster(pop_2050_ssp585_project, crs = crs(EMT), method = "bilinear")
pop_2050_ssp585_crop <- crop(pop_2050_ssp585_proj, extent(EMT))
pop_2050_ssp585_resampled <- resample(pop_2050_ssp585_crop, EMT, method = "bilinear")
plot(pop_2050_ssp585_resampled)
writeRaster(pop_2050_ssp585_resampled, "F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2050_ssp585_aligned.tif", overwrite = TRUE)


#  2080s

pop_2080_ssp126_proj <- projectRaster(pop_2080_ssp126_project, crs = crs(EMT), method = "bilinear")
pop_2080_ssp126_crop <- crop(pop_2080_ssp126_proj, extent(EMT))
pop_2080_ssp126_resampled <- resample(pop_2080_ssp126_crop, EMT, method = "bilinear")
plot(pop_2080_ssp126_resampled)
writeRaster(pop_2080_ssp126_resampled, "F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2080_ssp126_aligned.tif", overwrite = TRUE)

pop_2080_ssp245_proj <- projectRaster(pop_2080_ssp245_project, crs = crs(EMT), method = "bilinear")
pop_2080_ssp245_crop <- crop(pop_2080_ssp245_proj, extent(EMT))
pop_2080_ssp245_resampled <- resample(pop_2080_ssp245_crop, EMT, method = "bilinear")
plot(pop_2080_ssp245_resampled)
writeRaster(pop_2080_ssp245_resampled, "F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2080_ssp245_aligned.tif", overwrite = TRUE)

pop_2080_ssp585_proj <- projectRaster(pop_2080_ssp585_project, crs = crs(EMT), method = "bilinear")
pop_2080_ssp585_crop <- crop(pop_2080_ssp585_proj, extent(EMT))
pop_2080_ssp585_resampled <- resample(pop_2080_ssp585_crop, EMT, method = "bilinear")
plot(pop_2080_ssp585_resampled)
writeRaster(pop_2080_ssp585_resampled, "F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2080_ssp585_aligned.tif", overwrite = TRUE)



# REload pop density data
pop_2020s_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2020_ssp126_aligned.tif")
pop_2020s_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2020_ssp245_aligned.tif")
pop_2020s_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2020_ssp585_aligned.tif")

pop_2050s_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2050_ssp126_aligned.tif")
pop_2050s_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2050_ssp245_aligned.tif")
pop_2050s_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2050_ssp585_aligned.tif")

pop_2080s_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2080_ssp126_aligned.tif")
pop_2080s_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2080_ssp245_aligned.tif")
pop_2080s_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/RF/pop_density/pop_2080_ssp585_aligned.tif")



# Stack layers
r_stack <- stack(urban_r, pop_2020_ssp126_resampled)
names(r_stack) <- c("urban", "population")

# Stack layers
r_stack_2020_ssp245 <- stack(urban_r, pop_2020_ssp245_resampled)
names(r_stack_2020_ssp245) <- c("urban", "population")

# Stack layers
r_stack_2020_ssp585 <- stack(urban_r, pop_2020_ssp585_resampled)
names(r_stack_2020_ssp585) <- c("urban", "population")

# Stack layers
r_stack_2050_ssp126 <- stack(urban_r, pop_2050_ssp126_resampled)
names(r_stack_2050_ssp126) <- c("urban", "population")

r_stack_2050_ssp245 <- stack(urban_r, pop_2050_ssp245_resampled)
names(r_stack_2050_ssp245) <- c("urban", "population")

r_stack_2050_ssp585 <- stack(urban_r, pop_2050_ssp585_resampled)
names(r_stack_2050_ssp585) <- c("urban", "population")

# Stack layers
r_stack_2080_ssp126 <- stack(urban_r, pop_2080_ssp126_resampled)
names(r_stack_2080_ssp126) <- c("urban", "population")

r_stack_2080_ssp245 <- stack(urban_r, pop_2080_ssp245_resampled)
names(r_stack_2080_ssp245) <- c("urban", "population")

r_stack_2080_ssp585 <- stack(urban_r, pop_2080_ssp585_resampled)
names(r_stack_2080_ssp585) <- c("urban", "population")


# Sample 10,000 random points with data
set.seed(123)
sample_data <- sampleRandom(r_stack, size = 100000, na.rm = TRUE, sp = TRUE)
df <- as.data.frame(sample_data)

glm_model <- glm(urban ~ population, data = df, family = binomial)

# Predict probability using logistic regression
urban_prob_glm <- predict(r_stack, model = glm_model, type = "response")
# Plot random forest-based prediction
plot(urban_prob_glm, main = "Predicted Probability of Urban Expansion (RF)", col = viridis::magma(100))

# Predict probability using logistic regression
urban_prob_glm_2020_ssp245 <- predict(r_stack_2020_ssp245, model = glm_model, type = "response")
# Plot random forest-based prediction
plot(urban_prob_glm_2020_ssp245, main = "Predicted Probability of Urban Expansion (RF)", col = viridis::magma(100))

# Predict probability using logistic regression
urban_prob_glm_2020_ssp585 <- predict(r_stack_2020_ssp585, model = glm_model, type = "response")
# Plot random forest-based prediction
plot(urban_prob_glm_2020_ssp585, main = "Predicted Probability of Urban Expansion (RF)", col = viridis::magma(100))

# Predict probability using logistic regression
urban_prob_glm_2050_ssp126 <- predict(r_stack_2050_ssp126, model = glm_model, type = "response")
# Plot random forest-based prediction
plot(urban_prob_glm_2050_ssp126, main = "Predicted Probability of Urban Expansion (RF)", col = viridis::magma(100))

# Predict probability using logistic regression
urban_prob_glm_2050_ssp245 <- predict(r_stack_2050_ssp245, model = glm_model, type = "response")
# Plot random forest-based prediction
plot(urban_prob_glm_2050_ssp245, main = "Predicted Probability of Urban Expansion (RF)", col = viridis::magma(100))

# Predict probability using logistic regression
urban_prob_glm_2050_ssp585 <- predict(r_stack_2050_ssp585, model = glm_model, type = "response")
# Plot random forest-based prediction
plot(urban_prob_glm_2050_ssp585, main = "Predicted Probability of Urban Expansion (RF)", col = viridis::magma(100))

# Predict probability using logistic regression
urban_prob_glm_2080_ssp126 <- predict(r_stack_2080_ssp126, model = glm_model, type = "response")
# Plot random forest-based prediction
plot(urban_prob_glm_2080_ssp126, main = "Predicted Probability of Urban Expansion (RF)", col = viridis::magma(100))

# Predict probability using logistic regression
urban_prob_glm_2080_ssp245 <- predict(r_stack_2080_ssp245, model = glm_model, type = "response")
# Plot random forest-based prediction
plot(urban_prob_glm_2080_ssp245, main = "Predicted Probability of Urban Expansion (RF)", col = viridis::magma(100))

# Predict probability using logistic regression
urban_prob_glm_2080_ssp585 <- predict(r_stack_2080_ssp585, model = glm_model, type = "response")
# Plot random forest-based prediction
plot(urban_prob_glm_2080_ssp585, main = "Predicted Probability of Urban Expansion (RF)", col = viridis::magma(100))

plot(urban_r)

# Sum predicted probability and historical urban presence
urban_combined_2020_ssp126 <- urban_r + urban_prob_glm
plot(urban_combined_2020_ssp126)
urban_combined_2020_ssp245 <- urban_r + urban_prob_glm_2020_ssp245
urban_combined_2020_ssp585 <- urban_r + urban_prob_glm_2020_ssp585
urban_combined_2050_ssp126 <- urban_r + urban_prob_glm_2050_ssp126
urban_combined_2050_ssp245 <- urban_r + urban_prob_glm_2050_ssp245
urban_combined_2050_ssp585 <- urban_r + urban_prob_glm_2050_ssp585
urban_combined_2080_ssp126 <- urban_r + urban_prob_glm_2080_ssp126
urban_combined_2080_ssp245 <- urban_r + urban_prob_glm_2080_ssp245
urban_combined_2080_ssp585 <- urban_r + urban_prob_glm_2080_ssp585

# Function to rescale urban raster to 0â€“1
rescale_raster <- function(r) {
  (r - cellStats(r, stat = 'min')) / 
    (cellStats(r, stat = 'max') - cellStats(r, stat = 'min'))
}

urban_rescaled_2020_ssp126 <- rescale_raster(urban_combined_2020_ssp126)
plot(urban_rescaled_2020_ssp126)
urban_rescaled_2020_ssp245 <- rescale_raster(urban_combined_2020_ssp245)
urban_rescaled_2020_ssp585 <- rescale_raster(urban_combined_2020_ssp585)
urban_rescaled_2050_ssp126 <- rescale_raster(urban_combined_2050_ssp126)
urban_rescaled_2050_ssp245 <- rescale_raster(urban_combined_2050_ssp245)
urban_rescaled_2050_ssp585 <- rescale_raster(urban_combined_2050_ssp585)
urban_rescaled_2080_ssp126 <- rescale_raster(urban_combined_2080_ssp126)
urban_rescaled_2080_ssp245 <- rescale_raster(urban_combined_2080_ssp245)
urban_rescaled_2080_ssp585 <- rescale_raster(urban_combined_2080_ssp585)
plot(urban_rescaled_2080_ssp585)



# resample forest to align with predictors
water_r <- resample(water, EMT, method = "near")

# resample elevation and slope and to match other predictors
elevation <- resample(elevation, EMT, method = "ngb")
slope <- resample(slope, EMT, method = "ngb")
plot(slope)

# Stack all environmental rasters (raster stack)
environmental_var_stack <- raster::stack(EMT, EXT, PPT_at, PPT_sm, PPT_wt, elevation, slope)
environmental_var_stack

plot(environmental_var_stack)


names(environmental_var_stack) <- c(
  "EMT", "EXT", "PPT_at", "PPT_sm",
  "PPT_wt", "elevation", "slope"
)


# Add land cover data

# Stack all environmental rasters (raster stack)
environmental_var_stack <- raster::stack(EMT, EXT, PPT_at, PPT_sm, PPT_wt, elevation, slope,
                                         water_r, forest_r, wetland_r, cropland_r, grassland_r,
                                         urban_r)
environmental_var_stack

plot(environmental_var_stack)


names(environmental_var_stack) <- c(
  "EMT", "EXT", "PPT_at", "PPT_sm",
  "PPT_wt", "elevation", "slope", "water", "forest","wetland", 
  "cropland", "grassland", "urban"
)



# Read study area 
shapefile_path <- "F:/Uillinois_data/study_area/study_area_projected.shp"
studyarea <- st_read(shapefile_path)  # Path to your study area shapefile

study_area <- studyarea %>%
  # Transform the CRS of the ppr_region to match that of environmental variables(environmental_var_stack)
  st_transform(crs = crs(environmental_var_stack)) %>%
  # Remove the Z dimension, if present
  st_zm() %>%
  # Convert sf (simple feature) to sp (spatial) object
  as_Spatial()

plot(EMT)
plot(study_area, add = TRUE, border = "red", lwd = 2)


##3. Second step is to load species list and observations 

# I start by loading the csv file that contains the list of all species for the prairie region, filter and modify the data, and adds columns for model performance and environmental variables
modelPerformanceAllSpecies <- read.csv("F:/Uillinois_data/analysis/habitat_suitability/MWCASCBiodiversityAllSpecies_amphibians.csv") %>%
  filter(n_MWCASC > 20) %>% # this code filters and keep rows where the n_SECanada column has  20 observation records or more. 20 records is the minimum threshold required for fitting models for the SE Canada region
  dplyr::select(-X) %>%
  # the below code adds to two columns with variables mean_auc and mean_threshold, initialized with a NA value in inorder to store future model performance values
  mutate(mean_auc = NA,
         mean_threshold = NA) %>%
  # add blank columns for mean species values of each environmental variable, and filling them with NA values
  cbind(., t(rep(NA,length(names(environmental_var_stack)))))

dim(modelPerformanceAllSpecies)  # checks the number of rows and columns in the species list
head(modelPerformanceAllSpecies)# checks some few rows to see how the data looks like with the columns added
View(modelPerformanceAllSpecies)

#add environmental variable names to data frame
# the code below retrieves and adds new columns to the modelPerformanceAllSpecies file, with names of each environmental variable in the raster stack, starting from the 8th column to the last column (ncol(modelPerformanceAllSpecies))
names(modelPerformanceAllSpecies)[8:ncol(modelPerformanceAllSpecies)] <- names(environmental_var_stack)

#Now reprint the modelPerformanceAllSpecies data to check if the environmental variables have been successfully added 
head(modelPerformanceAllSpecies)
View(modelPerformanceAllSpecies)

# Load species observation data 
amphibian_observations <- read.csv("F:/Uillinois_data/analysis/habitat_suitability/amphibian_observations_cleaned.csv")

# Combine all observations
species_observations <- rbind(amphibian_observations) 
head(species_observations)

# Species observations are still in dataframe format, hence, a need to convert the data frame to an sf object
species_observations_sf <- st_as_sf(
  species_observations,
  coords = c("longitude", "latitude"),
  crs = 4326,  # WGS84 coordinate reference system
  remove = FALSE  # Keeps the original longitude and latitude columns
)

# Check the structure
print(species_observations_sf)

# Reproject the sf object to the CRS of bio4 (e.g., a raster layer)
species_observations_transformed <- st_transform(species_observations_sf, crs = st_crs(environmental_var_stack))

# Remove rows where "species" column is NA
species_observations_cleaned <- species_observations_transformed[!is.na(species_observations_transformed$species), ]

# Check the result
head(species_observations_cleaned)
# Plot observation points and visualize on climate maps
plot(environmental_var_stack[[1]], main = "Reprojected & Masked Bio9 Layer")
# Add the species points
plot(species_observations_cleaned, 
     add = TRUE, 
     col = "red", 
     pch = 16)


# Step 2: Remove Z/M dimensions if present (if needed for conversion to Spatial)
species_observations_reproj <- st_zm(species_observations_cleaned)

# Get the extent of environmental_var_stack as an sf polygon
env_extent <- as(extent(environmental_var_stack), "SpatialPolygons")
crs(env_extent) <- crs(environmental_var_stack)
env_extent_sf <- st_as_sf(env_extent)

# Clip points that fall within extent
species_observations_clipped <- st_intersection(species_observations_reproj, env_extent_sf)

# Plot
plot(environmental_var_stack[[1]], main = "Clipped Species Observations on Bio4")
plot(st_geometry(species_observations_clipped), 
     add = TRUE, 
     col = "red", 
     pch = 16)


### Use loop to create raster for each taxonomic group.
# In this section, I will start by defining a group vector, by assigning the taxonomic groups that will be iterated in a loop
# Print unique names in the "group" column
unique_groups <- unique(species_observations_clipped$group)# get group names from observation data
print(unique_groups)

group_vector <- c("amphibians")

# The second stage is to Store target group Sampling raster in a list (named by taxon)
# Here, I will first create an empty list to store raster objects, that will be created as kernel density estimates for each taxonomic group
observations_kde_list <- list()

names(environmental_var_stack)


# Next, is to define resolution and extent based on environmental_mask. This will ensure that all raster layers that will be generated, will follow thesame resolution and spatial extents as those of the stacked raster layers created at the early stage (e.g., forest
# first, create an environmental mask for one of the stacked raster layer (here i use forest), which will be used in setting the desired resolution and extent for all other raster objects as i move forward
environmental_mask <- terra::rast(environmental_var_stack$EMT)
# second, I create a target resolution to be used for all raster layers as I proceed, by extracting the resolution of the masked raster layer (forest), using the terra package
target_resolution <- terra::res(environmental_mask)
# third, I also create a target extent that will be used for all raster layers to be developed, by extracting the extent of the masked raster
target_extent <- terra::ext(environmental_mask)

environmental_mask
plot(environmental_mask)
target_resolution
target_extent

for(g in group_vector){ # this function defines a loop over each element in the group_vector defined above (birds, mammals, amphibians and reptiles), where data specific to each group, g, will be processed independently in each iteration in the loop
  # after defining the loop function, the next thing is to ensure that each species observation is filtered to include only records for the group, g, with these records converted to a spatial format for further processing
  group_g_observations <- species_observations_clipped %>%
    filter(group == g) %>%
    slice_sample(n = 100000)  # for each group with filtered records, I randomly sample about 100,000 observations for producing KDE. 100,000 observations seem to be a manageable threshold record for each group in every KDE operation
  
  # Check if there are any observations to process
  if (nrow(group_g_observations) == 0) {
    message("No observations for group: ", g)
    next  # Skip to the next group if no data
  }
  summary(group_g_observations)
  
  # next, for each group observation g, convert the coordinates to simple feature feature (sf) objects using the sf package, so it becomes compatible with spatial feature functions in R
  group_g_observations_sf <- st_as_sf(group_g_observations, coords = c("longitude", "latitude"), crs = 4326) # here, I have converted the coordinates to EPSG:4326, the standard World Geodetic coordinate system 
  
  # the next thing is to project the group_g_observations_sf data to match that of the stacked environmental layers
  group_g_observations_sf <- st_transform(group_g_observations_sf, st_crs(environmental_var_stack))
  
  # I will now calculate KDE (kernel density estimates) for each group observation g, by masking the calculations (raster data) to the target resolution defined in the earlier face of the codes, using the resolution of one of the stacked predictors (forest). I am using the spatialEco package to do this
  kde_result <- spatialEco::sp.kde(
    x = group_g_observations_sf,
    res = target_resolution,   # Set KDE resolution to match environmental_mask
    standardize = TRUE #normalizes the density values to make them comparable across groups.
  )
  # Check the class of the KDE result and resample if needed
  # here, there is a need to verify is the KDE results produced are SpatRaster objects, considering that the package used now is the terra package, which has replaced the previos Rgeos package that has depreciated
  # the code therefore ensures that, If kde_result is not a SpatRaster object, then, the stop() function is executed to halt the operation and display the message "KDE result is not a SpatRaster." This ensures that only valid SpatRaster objects are processed in the next steps.
  if (!inherits(kde_result, "SpatRaster")) {
    stop("KDE result is not a SpatRaster.")
  }
  
  # After calculating the KDE for each species observation, g, there is a need ensure that the results fall within the geographic boundaries of the target extent (forest), define in the earlier stage of this script
  kde_result <- terra::crop(kde_result, environmental_mask)  # Crop to target extent using the crop function of the terra package
  kde_result <- terra::resample(kde_result, environmental_mask, method = "bilinear")  # although the target resolution has been specified in the KDE calculations, it is always a good approach to resample to target resolution again after coping the target extent. Also, the bilinear interpolation in the raster resampling, ensures that new pixel values are calculated based on the weighted average of surrounding pixels, yielding a smoother result
  
  # To ensure that there is no mismatch in spatial extents and resolutions between the calculated KDEs and masked or stacked environmental layers, there is a need to mask the KDE result with the stacked or masked environmental layer (forest)
  observations_kde_list[[g]] <- terra::mask(kde_result, environmental_mask)
}


# Plot KDE results for each group
#par(mfrow = c(1, 1))  # Arrange plots in a 2x2 grid

for (g in names(observations_kde_list)) {
  plot(observations_kde_list[[g]], main = paste("KDE for", g))
}


# Set species common name: here, I extract the common name of each species in each row i (within the modelPerformanceAllSpecies csv file), and store it in a new variable called scientific_name_i, for easy reference in the loop iterations
for (i in 1:nrow(modelPerformanceAllSpecies)) {
  # Extract key species attributes
  group_i <- modelPerformanceAllSpecies$group[i]  
  genus_i <- modelPerformanceAllSpecies$genus[i]
  species_i <- modelPerformanceAllSpecies$species[i]
  scientific_name_i <- modelPerformanceAllSpecies$scientific_name[i]
  common_name_i <- modelPerformanceAllSpecies$scientific_name[i]
  
  message("\nProcessing species: ", scientific_name_i, " (", genus_i, " ", species_i, ") in group: ", group_i)
  
  # Ensure KDE raster exists for this group
  if (!group_i %in% names(observations_kde_list)) {
    message("No KDE raster available for group: ", group_i, " - Skipping species: ", scientific_name_i)
    next
  }
  observations_kde_group_i <- observations_kde_list[[group_i]]
  
  # Filter species observations
  species_i_sp <- species_observations_clipped %>%
    filter(scientific_name == scientific_name_i) %>%
    slice_sample(n = 1, by = square_id)  # Avoids spatial autocorrelation issues
  
  if (nrow(species_i_sp) == 0) {
    message("No valid occurrences found for species: ", scientific_name_i, " - Skipping.")
    next
  }
  
  # Convert species occurrence data to spatial format
  species_i_sp <- st_as_sf(species_i_sp, coords = c("longitude", "latitude"), crs = 4326)
  
  # Ensure study_area is an sf object and matches CRS
  study_area <- st_as_sf(study_area)
  
  if (st_crs(species_i_sp) != st_crs(study_area)) {
    message("Transforming CRS of study area to match species observations.")
    study_area <- st_transform(study_area, st_crs(species_i_sp))
  }
  
  # Print key elements for debugging (optional)
  print(observations_kde_group_i)
  
  # Intersect species points with the study area
  species_i_intersects_SE <- st_intersects(species_i_sp, study_area, sparse = FALSE)
  
  # Filter species points by intersection (keep only points inside the study area)
  species_i_sp <- species_i_sp[which(rowSums(species_i_intersects_SE) > 0), ]
  
  # Check if there are any remaining points after filtering
  if (nrow(species_i_sp) == 0) {
    message("No valid intersection found for species: ", scientific_name_i, " - Skipping.")
    modelPerformanceAllSpecies$n_MWCASC[i] <- 0  # Assign zero if no observations remain
    next
  }
  
  # Transform the CRS of the filtered points to match the environmental variable stack
  species_i_sp <- st_transform(species_i_sp, st_crs(environmental_var_stack))
  
  # Extract unique observation points (latitude and longitude), removing duplicate coordinates
  obs_species_i <- unique(st_coordinates(species_i_sp))
  
  # Convert the matrix of coordinates into a data frame
  obs_species_i <- data.frame(longitude = obs_species_i[, 1],
                              latitude = obs_species_i[, 2])
  
  # Check the first few records (optional for debugging)
  head(obs_species_i)
  
  # Save sample size: store the count of unique observation points in modelPerformanceAllSpecies
  modelPerformanceAllSpecies$n_MWCASC[i] <- nrow(obs_species_i)
  
  # Optional: Print progress update
  message("Processed ", nrow(obs_species_i), " unique occurrences for species: ", common_name_i)
  
  # Define output folder and create it if it doesn't exist
  output_dir_range <- "F:/Uillinois_data/analysis/habitat_suitability/species_range1"
  dir.create(output_dir_range, recursive = TRUE, showWarnings = FALSE)
  
  # Only model species with >= 20 observations
  if(modelPerformanceAllSpecies$n_MWCASC[i] >= 20){# here, i first of all check and select the number of unique observations filtered for the prairie region (n_prairie) in each row of the modelPerformanceAllSpecies data, with records  >= 20; 20 is the minimum threshold)
    # I now assign the obs_species_i data frame (which contains the unique coordinates in each grid id) into a new variable "species_i_ppr_sp", assign lon and lat coordinates to make it a spatial object, and finally project the variable to a similar CRS with the stacked environmental variables
    species_i_sp <- obs_species_i
    coordinates(species_i_sp) <- c("longitude", "latitude")
    species_i_sp@proj4string <- raster::crs(environmental_var_stack)
    
    # Generate a 50 km buffer around each observation point
    species_i_buffers <- spTransform(species_i_sp, CRS = raster::crs(environmental_var_stack)) %>%
      raster::buffer(width = 50000)  # 5 km buffer around each observation
    
    # Convert the buffer to an sf object for easier handling
    species_i_buffers_sf <- st_as_sf(species_i_buffers)
    
    # Dissolve and merge all buffers
    species_i_buffers_dissolved <- species_i_buffers_sf %>%
      st_union()  # Dissolve all buffers into a single polygon
    
    # Define species name and file path
    species_names <- modelPerformanceAllSpecies$species[i]
    shapefile_path <- file.path(output_dir_range, paste0(gsub(" ", "_", species_names), "_range.shp"))
    
    # Save the shapefile
    st_write(species_i_buffers_dissolved, shapefile_path, delete_layer = TRUE)
    
    # Plot the dissolved buffer (clipped to the study area) and the study area
    #par(mfrow = c(1, 1))  # Set up a single panel for plotting
    #plot(st_geometry(species_i_buffers_dissolved), main = "Clipped Dissolved 5 km Buffer for Fowler's Toad Observations", col = "lightblue")
    #plot(st_geometry(clipped_study_area_proj), add = TRUE, border = "black")  # Overlay study area
    
    
    ggplot() +
      geom_sf(data = study_area, fill = "gray95", color = "black") +
      geom_sf(data = st_as_sf(species_i_buffers_dissolved), color = "darkgreen", size = 2, alpha = 0.7) +
      theme_minimal() +
      labs(title = "Species Observations",
           subtitle = "Species Observations within the Study Area",
           caption = "Species observation points have been transformed to match CRS")
    
    
    # Now Calculate species range size
    species_i_rangesize <- species_i_buffers_dissolved %>% 
      st_intersection(study_area) %>%  # Intersects the species buffer with the clipped study area to remove parts outside
      st_area() %>%  # Calculates the total area of the intersected buffers
      as.numeric() %>%  # Converts the calculated area to numeric for ease of further analysis
      sum()  # Sums up areas of multiple polygons to get the total range size
    species_i_rangesize
    
    # Estimate study area size
    study_area_size <- st_area(study_area) %>% as.numeric()
    study_area_size 
    
    # Ensure the buffer has the same CRS as the environmental variable stack
    species_i_buffers_dissolved <- st_transform(species_i_buffers_dissolved, crs = st_crs(environmental_var_stack))
    
    # Convert the dissolved buffer to an sp object
    species_i_buffers_dissolved_sp <- as(species_i_buffers_dissolved, "Spatial")
    
    # Now apply the crop and mask functions
    if(species_i_rangesize >= 0.9 * 2.018284e+12){ # Use full study area if range size is >= 90% of study area
      environmental_var_stack_i <- environmental_var_stack  # Use the entire study area
    } else {
      environmental_var_stack_i <- environmental_var_stack %>%
        raster::crop(., species_i_buffers_dissolved_sp) %>%  # Crop environmental data to species' range
        raster::mask(., species_i_buffers_dissolved_sp)  # Mask environmental data to species' range
    }
    
    # Plot to visualize the environmental variable stack and buffer
    plot(environmental_var_stack_i$EMT)
    plot(species_i_buffers_dissolved, add = TRUE, lty = 5)  # Overlay species buffer on top of the environmental data
    
    # Use the full study area, regardless of the species' range size
    # environmental_var_stack_i <- environmental_var_stack  # Use the entire study area
    
    # Convert species_i_sp to an sf object if it is a SpatialPointsDataFrame
    species_i_sf <- st_as_sf(species_i_sp)
    
    # Next, is to extract values of environmental_var_stack_i for all obs_species_i
    modelPerformanceAllSpecies[i,8:ncol(modelPerformanceAllSpecies)] <- raster::extract(environmental_var_stack_i,
                                                                                        species_i_sf) %>%
      # first, this code ensures that the raster values of each environmental variable (within the stacked raster) is extracted for every given location of a species, within the species observation variable, "species_i_ppr_sp".
      # through this approach, a data structure is created for each observation point, where each column represents each environmental variable, and each row represents each observation 
      as_tibble(.) %>% # here, the data structure is converted to a tibble, a modern data frame structure in R that facilitates subsequent operations
      summarize_all(., mean, na.rm = TRUE) # this operation ensures that the mean of each environmental variable is calculated across observations for the said variable, ignoring all NA values
    # In the definition,modelPerformanceAllSpecies[i, 8:ncol(modelPerformanceAllSpecies)] <- ..., the calculated means areassigned to columns 8 onward for each row, i, of the modelPerformanceAllSpecies data frame. The results of these columns are required for evaluating model performance or habitat suitability for species in subsequent analysis
    
    modelPerformanceAllSpecies[i,8:ncol(modelPerformanceAllSpecies)]
    
    # Because the environmental_var_stack_i variable created above is still working with the raster package, there is need to the data to a SpatRaster in order to avoid model fitting and evaluation errors
    environmental_var_stack_i <- terra::rast(environmental_var_stack_i)
    # after converting to a SpatRaster, we need to ensure that our species KDE calculated in th earlier stage of this analysis matches the extent and resolution of our newly created environmental_var_stack_ic SpatRaster object
    # It should be noted that KDE raster captures observation biases
    observationbias_species_i <- observations_kde_group_i %>%
      terra::crop(environmental_var_stack_i) %>%
      terra::mask(environmental_var_stack_i)
    observationbias_species_i
    
    
    # Check if the observation bias raster has any values
    plot(observationbias_species_i)
    
    # If it's empty or not valid, skip further processing for this species
    if (all(is.na(values(observationbias_species_i)))) {
      message("Observation bias is empty for species: ", scientific_name_i, " - Skipping further analysis")
    } else {
      # Plot the observation bias for species
      plot(observationbias_species_i)
    }
  }
  
  
  # Next, is to generate background points based on species range size pixels
  # However, I will first, calculate the number of pixels in the species range, using the global() function from the terra package 
  species_i_rangepixels <- global(((observationbias_species_i[[1]] * 0) + 1), 'sum', na.rm = TRUE)[1, 1]
  # Here, the observationbias_species_i[[1]] * 0 creates a raster with the same structure as observationbias_species_i but filled with zeros
  # + 1 then turns all pixel values to 1, representing each pixel as a unit.
  #global(..., 'sum', na.rm = TRUE) then sums all these pixel values, providing the count of pixels that cover the species' range
  # the [1, 1] extracts this count from the result, storing it in species_i_rangepixels.
  species_i_rangepixels
  
  # Now, determine background points based on species range size pixels
  if(species_i_rangepixels < 100000){
    # Use 20% for small ranges i.e., assign backg_n as 20% of species_i_rangepixels
    backg_n <- round(species_i_rangepixels*0.2, 0)
  }else if(species_i_rangepixels >= 100000 & species_i_rangepixels < 250000){
    # Use 10% for medium ranges i.e., assign backg_n as 10% of species_i_rangepixels
    backg_n <- round(species_i_rangepixels*0.1, 0)
  }else if(species_i_rangepixels >= 250000){
    # Use 5% for big ranges
    backg_n <- round(species_i_rangepixels*0.05, 0) #rounds the calculated value to the nearest integer for easier indexing
  }
  
  backg_n
  
  
  # Sample background points, using bias specific to a target group
  ext <- ext(observationbias_species_i)
  # Generate background points using terra::spatSample()
  backg <- terra::spatSample(observationbias_species_i, 
                             size = backg_n, method = "random", 
                             na.rm = TRUE, xy = TRUE)
  backg
  
  colnames(backg)
  
  backg <- backg[, 1:2]  # Select only the first two columns
  colnames(backg) <- c("lon", "lat")
  
  # Make one sf for background
  backg_sf <- backg %>%
    as.data.frame(.) %>%
    st_as_sf(.,
             coords = c("lon", "lat"),
             crs = raster::crs(environmental_var_stack_i)) %>%
    mutate(p = 0) %>%
    cbind(., st_coordinates(.))
  
  head(backg_sf)
  
  # Make sf object with presence and background points
  species_i_presbackg_sf <- species_i_sf %>%
    st_as_sf(., crs = raster::crs(environmental_var_stack_i)) %>%
    mutate(p = 1) %>%
    cbind(., st_coordinates(.)) %>%
    rbind(backg_sf)
  
  head(species_i_presbackg_sf)
  tail(species_i_presbackg_sf)
  
  # Make sure all points have values for each environmental variable
  species_i_pb_extract <- raster::extract(environmental_var_stack_i,
                                          species_i_presbackg_sf) %>%
    as.data.frame(.)
  
  head(species_i_pb_extract)
  #View(species_i_pb_extract)
  
  # Omit NA row names
  species_i_omit_rownames <- row.names(species_i_pb_extract[is.na(species_i_pb_extract$forest) |
                                                              is.na(species_i_pb_extract$water)|
                                                              is.na(species_i_pb_extract$wetlands)|
                                                              is.na(species_i_pb_extract$annual.croplands)|
                                                              is.na(species_i_pb_extract$barren.lands)|
                                                              is.na(species_i_pb_extract$nativegrass)|
                                                              is.na(species_i_pb_extract$perennial.croplands)|
                                                              is.na(species_i_pb_extract$roads)|
                                                              is.na(species_i_pb_extract$settlements)|
                                                              is.na(species_i_pb_extract$tmax)|
                                                              
                                                              is.na(species_i_pb_extract$prec),]) 
  
  
  # Alternative approach to omitting row names
  #species_i_omit_rownames <- rownames(species_i_pb_extract[rowSums(is.na(species_i_pb_extract[
  #c("forest", "water", "wetlands", "annual.croplands", "barren.lands",
  #"nativegrass", "perennial.croplands", "roads", "settlements",
  #"tmax", "tmin", "prec")])) > 0, ])
  
  species_i_omit_rownames
  summary(species_i_omit_rownames)
  
  
  # Define species presence/background data
  species_i_presbackg_sf <- species_i_presbackg_sf %>%
    filter(!(row.names(.) %in% species_i_omit_rownames)) # Remove rows with NA values
  
  # Run spatial blocking to prepare data for cross-validation
  sb <- spatialBlock(speciesData = species_i_presbackg_sf %>%
                       filter(!(row.names(.) %in% species_i_omit_rownames)),
                     species = "p",  # Presence column (1 for presence, 0 for background)
                     rasterLayer = environmental_var_stack_i,
                     selection = "systematic",
                     rows = 10,
                     cols = 10,  # Define the number of rows and columns in the grid
                     k = 5,  # Number of folds for cross-validation
                     biomod2Format = TRUE)  # Format compatible with biomod2 package
  
  # Add fold ID to dataset
  species_i_presbackg_sf <- species_i_presbackg_sf %>%
    filter(!(row.names(.) %in% species_i_omit_rownames)) %>%
    mutate(fold = sb$foldID)
  
  # Ensure the fold assignments are properly distributed
  table(species_i_presbackg_sf$fold)  # Check the distribution of folds
  
  # Filter out rows with missing values
  species_i_pb_extract <- species_i_pb_extract %>%
    filter(!(row.names(.) %in% species_i_omit_rownames))
  
  # Initialize evaluation metrics
  species_i_eval_summary <- data.frame(fpr = c(), tpr = c(), fold = c())
  species_i_maxent_models <- list()  # List to store Maxent models
  species_i_px <- list()  # List to store habitat suitability predictions
  AUCs_i <- vector(mode = "numeric", length = 5)  # Store AUCs for each fold
  
  # Identify folds with no observations (e.g. large range, but small clustered points like Great Plains Toad)
  species_i_foldvector <- species_i_presbackg_sf %>%
    st_drop_geometry(.) %>%
    filter(p == 1) %>%
    group_by(fold) %>%
    summarize(total = n()) %>%
    pull(fold)
  
  # Loop through folds for cross-validation
  for (k in 1:5) {
    # Split data into training and testing sets based on fold
    trainSet <- which(sb$foldID != k)
    testSet <- which(sb$foldID == k)
    
    # Check if both training and testing sets have data
    if (length(trainSet) == 0 || length(testSet) == 0) {
      cat("No observations in fold", k, ", skipping this fold.\n")
      next  # Skip this fold if no observations are available
    }
    
    
    # Check column names in the species_i_presbackg_sf to verify the existence of the 'ID' column
    cat("Column names in species_i_presbackg_sf:", colnames(species_i_presbackg_sf), "\n")
    
    # Remove the 'ID' column from the environmental and presence-background data
    # If 'ID' column exists in species_i_presbackg_sf, it will be removed
    if("ID" %in% colnames(species_i_presbackg_sf)) {
      species_i_presbackg_sf_no_ID <- species_i_presbackg_sf %>%
        st_drop_geometry() %>%
        dplyr::select(-ID)  # Remove 'ID' column from the spatial data
    } else {
      cat("'ID' column not found in species_i_presbackg_sf\n")
      species_i_presbackg_sf_no_ID <- species_i_presbackg_sf  # Keep the data as is if no 'ID' column
    }
    
    # Remove the 'ID' column from the environmental data (assuming it's named 'ID' in species_i_pb_extract)
    species_i_pb_extract_no_ID <- species_i_pb_extract[, !colnames(species_i_pb_extract) %in% "ID"]
    species_i_pb_extract_no_ID
    
    # Subset the training and testing data
    trainData <- species_i_presbackg_sf[trainSet, ]
    testData <- species_i_presbackg_sf[testSet, ]
    trainEnv <-  species_i_pb_extract_no_ID[trainSet, ]
    testEnv <-  species_i_pb_extract_no_ID[testSet, ]
    
    
    # Now, fit the MaxEnt model using linear, quadratic, and hinge features
    
    # Fit Maxent model
    species_i_maxent_model <- maxent(
      x = trainEnv,  # Environmental variables for the training set
      p = trainData$p,  # Presence data for the training set
      a = trainData$background,  # Background data for the training set
      args = c("outputformat=cloglog", "betamultiplier=1", "maximumiterations=1000")  # Maxent model arguments
    )
    
    species_i_maxent_model
    
    # Store the fitted Maxent model
    species_i_maxent_models[[k]] <- species_i_maxent_model 
    
    # Get variable importance from the fitted Maxent model
    # Define output directory for variable importance (if not already defined)
    variable_importance_dir <- file.path("F:/Uillinois_data/analysis/habitat_suitability/amphibians/variable_importance_amphibian/range/plus_landcover")
    dir.create(variable_importance_dir, recursive = TRUE, showWarnings = FALSE)
    
    # Extract variable importance for the species
    if (!is.null(species_i_maxent_model)) {
      
      # Extract variable contribution and permutation importance
      variable_importance <- species_i_maxent_model@results
      
      # Optionally: keep only relevant variable importance rows
      var_imp_rows <- grep("contribution$|permutation.importance$", rownames(variable_importance), value = TRUE)
      variable_importance_filtered <- variable_importance[var_imp_rows, , drop = FALSE]
      
      # Print for debugging
      cat("Variable importance for", scientific_name_i, ":\n")
      print(variable_importance_filtered)
      
      # Save as CSV with species name
      variable_importance_path <- file.path(variable_importance_dir, paste0("variable_importance_", scientific_name_i, ".csv"))
      write.csv(variable_importance_filtered, file = variable_importance_path, row.names = TRUE)
      
      cat("Variable importance saved for", scientific_name_i, "\n")
      
    } else {
      cat("No model found for", scientific_name_i, "â€” skipping variable importance export.\n")
    }
    
    
    # Predict habitat suitability for the test data
    species_i_px[[k]] <- predict(environmental_var_stack_i, 
                                 species_i_maxent_models[[k]], 
                                 ext = ext, 
                                 na.rm = TRUE,
                                 progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot( species_i_px[[k]], main = paste("Final Predicted climatic Habitat Suitability for Species", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/continuous_surface_predictions_amphibians/range/plus_landcover"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir)) {
      dir.create(output_dir, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_i_px)) {
      if (!is.null(species_i_px[[k]])) {
        # Define the file path for each fold
        file_path <- paste0(output_dir, "habitat_suitability_species_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_i_px[[k]], filename = file_path, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    # Evualuate model
    
    species_predictions_avg <- list()
    species_i_eval <- list()  # Initialize list to store evaluation results
    species_i_eval_summary <- data.frame(
      fpr = numeric(),
      tpr = numeric(),
      mean_tpr = numeric(),
      sd_tpr = numeric(),
      se_tpr = numeric(),
      fold = integer()
    )
    
    # Initialize a vector to store AUC values
    auc_values <- numeric()
    
    
    if(k %in% species_i_foldvector){
      
      # Save evaluation for each fold
      species_i_eval[[k]] <- evaluate(p = species_i_presbackg_sf[testSet,] %>%
                                        st_drop_geometry(.) %>%
                                        filter(p == 1) %>%
                                        dplyr::select(-p, -fold),
                                      # p = presence, a = absence
                                      a = species_i_presbackg_sf[testSet,] %>%
                                        st_drop_geometry(.) %>%
                                        filter(p == 0) %>%
                                        dplyr::select(-p,-fold), 
                                      # model = maxent model
                                      model = species_i_maxent_models[[k]],
                                      # x = environmental variable raster stack
                                      x = environmental_var_stack_i)
      
      # Ensure the evaluation object is valid before proceeding
      if (!is.null(species_i_eval[[k]])) {
        
        # Extract FPR, TPR from model evaluation
        eval_df <- data.frame(
          fpr = species_i_eval[[k]]@FPR,
          tpr = species_i_eval[[k]]@TPR,  # Ensure TPR is included
          mean_tpr = mean(species_i_eval[[k]]@TPR, na.rm = TRUE),  # Compute mean TPR
          sd_tpr = sd(species_i_eval[[k]]@TPR, na.rm = TRUE),      # Compute SD of TPR
          se_tpr = sd(species_i_eval[[k]]@TPR, na.rm = TRUE) / sqrt(length(species_i_eval[[k]]@TPR)),  # Compute SE of TPR
          fold = k
        )
        
        # Step 1: Remove any existing NA rows in species_i_eval_summary
        species_i_eval_summary <- species_i_eval_summary %>%
          filter(!is.na(tpr))
        
        # Step 2: Ensure column names match
        eval_df <- eval_df %>%
          dplyr::select(all_of(colnames(species_i_eval_summary)))  # Keep column order consistent
        
        # Step 3: Append without introducing new NA values
        species_i_eval_summary <- bind_rows(species_i_eval_summary, eval_df)
        
        # Extract AUC value for the current fold and append it to the auc_values vector
        auc_values <- c(auc_values, species_i_eval[[k]]@auc)
        
        # Print number of test observations
        num_test_obs <- species_i_presbackg_sf[testSet, ] %>%
          st_drop_geometry() %>%
          filter(p == 1) %>%
          dplyr::select(-p, -fold) %>%
          nrow()
        
        print(paste("Number of test observations in fold", k, "is", num_test_obs))
        
      } else {
        cat(" Evaluation object is NULL for fold", k, "- Skipping.\n")
      }
    }
    
    
    # Calculate the average AUC for all folds (if auc_values contains any valid values)
    if (length(auc_values) > 0) {
      avg_auc <- mean(auc_values, na.rm = TRUE)
      cat("Average AUC across all folds for", scientific_name_i, ":", avg_auc, "\n")
      
      # Update the mean_auc column in modelPerformanceAllSpecies using the species name
      row_index <- which(modelPerformanceAllSpecies$scientific_name == scientific_name_i)
      
      if (length(row_index) == 1) {
        modelPerformanceAllSpecies$mean_auc[row_index] <- avg_auc
        cat("Average AUC saved for", scientific_name_i, "\n")
      } else {
        cat("Warning: Could not uniquely identify row for species", scientific_name_i, "\n")
      }
    } else {
      cat("No valid AUC values found for species", scientific_name_i, "\n")
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices <- which(!sapply(species_i_px, is.null))
    species_i_px_valid <- species_i_px[valid_indices]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid <- rep(auc_weights_valid, length(valid_indices))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_i_px_stack <- rast(species_i_px_valid)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_i_px_stack) == 1) {
      species_i_px_avg <- species_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_i_px_avg <- app(species_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_i_px_avg, main = paste("Average Habitat Suitability -", scientific_name_i))
    
    
    #species_predictions_avg <- list()
    species_predictions_avg[[scientific_name_i]] <- species_i_px_avg
    names(species_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir1 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/continuous_surface_predictions_amphibians/average/range/plus_landcover/"
    avg_suitability_path <- file.path(output_dir1, paste0("weighted_avg_habitat_suitability_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_i_px_avg, filename = avg_suitability_path, overwrite = TRUE)
      cat("Saved weighted average habitat suitability surface for", scientific_name_i, "\n")
      
      # Store in named list
      species_predictions_avg[[scientific_name_i]] <- species_i_px_avg
      
    } else {
      cat("species_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # --------------Obtaining optimal threshold---------------------------
    
    # ---------- Step 1: Extract thresholds (spec_sens) from each fold safely ----------
    fold_thresholds <- sapply(species_i_eval, function(eval_obj) {
      tryCatch({
        if (!is.null(eval_obj)) {
          dismo::threshold(eval_obj, 'spec_sens')
        } else {
          NA
        }
      }, error = function(e) NA)
    })
    
    # ---------- Step 2: Calculate valid weights ----------
    auc_weights <- (AUCs_i - 0.5)^2
    auc_weights[is.na(auc_weights)] <- 0  # zero out missing AUCs
    
    valid_folds <- which(!is.na(fold_thresholds) & auc_weights > 0)
    cat("Folds contributing to threshold calculation for", scientific_name_i, ":", paste(valid_folds, collapse = ", "), "\n")
    
    valid_thresholds <- fold_thresholds[valid_folds]
    valid_weights <- auc_weights[valid_folds]
    
    # ---------- Step 3: Compute the final threshold ----------
    if (length(valid_thresholds) > 0 && sum(valid_weights, na.rm = TRUE) > 0) {
      species_i_threshold <- weighted.mean(valid_thresholds, w = valid_weights, na.rm = TRUE)
    } else if (length(valid_thresholds) > 0) {
      species_i_threshold <- mean(valid_thresholds, na.rm = TRUE)
      cat("All weights were zero â€” used unweighted mean instead.\n")
    } else {
      species_i_threshold <- NA
      cat("No valid thresholds found â€” returning NA.\n")
    }
    
    cat("Final average threshold (spec_sens) for", scientific_name_i, ":", species_i_threshold, "\n")
    
    # ---------- Step 4: Save threshold to performance table ----------
    modelPerformanceAllSpecies$mean_threshold[modelPerformanceAllSpecies$scientific_name == scientific_name_i] <- species_i_threshold
    
    # Define file paths
    species_dir <- file.path("F:/Uillinois_data/analysis/habitat_suitability/amphibians/continuous_surface_predictions_amphibians/plus_landcover", gsub(" ", "_", scientific_name_i))
    dir.create(file.path(species_dir, "binary_amphibians"), showWarnings = FALSE, recursive = TRUE)
    
    write.csv(modelPerformanceAllSpecies,
              file = file.path(species_dir, paste0(scientific_name_i, "_performance.csv")),
              row.names = FALSE)
    cat("Model performance table saved as CSV for", scientific_name_i, "\n")
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary <- species_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary, main = paste("Binary Suitability for", scientific_name_i))
      
      binary_path <- file.path(species_dir, "binary_amphibians", paste0(scientific_name_i, "_mean_pixel_binary.tif"))
      writeRaster(
        species_i_binary,
        filename = binary_path,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    
    # ---------------------Conduct future projections------------------- 
    
    # Start by loading climatic variables
    
    # Access-CM2
    
    # A. ---------2011-2040-------------
    
    #------------2011-2040_ssp126--------------
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2020s_Access_ssp126 <- raster::stack( EMT_2020_ssp126, 
                                                                  EXT_2020_ssp126,
                                                                  PPT_at_2020_ssp126,
                                                                  PPT_sm_2020_ssp126,
                                                                  PPT_wt_2020_ssp126,
                                                                  elevation, slope,
                                                                  water_r_2020_ssp126, forest_r_2020_ssp126, 
                                                                  wetland_r_2020_ssp126, cropland_r_2020_ssp126, 
                                                                  grassland_r_2020_ssp126, urban_rescaled_2020_ssp126)
    
    environmental_var_stack_2020s_Access_ssp126
    
    plot(environmental_var_stack_2020s_Access_ssp126)
    
    
    names(environmental_var_stack_2020s_Access_ssp126) <- c(
      "EMT", "EXT", "PPT_at", "PPT_sm",
      "PPT_wt", "elevation", "slope", "water", "forest","wetland", 
      "cropland", "grassland", "urban")
    
    environmental_var_stack_2020s_Access_ssp126 <- terra::rast(environmental_var_stack_2020s_Access_ssp126)
    
    # Apply crop and mask to match study extent and remove irrelevant areas
    environmental_var_stack_2020s_Access_ssp126 <- environmental_var_stack_2020s_Access_ssp126 %>%
      terra::crop(environmental_var_stack_i) %>%
      terra::mask(environmental_var_stack_i)
    
    species_2020s_Access_ssp126_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2020s_Access_ssp126_i_px[[k]] <- predict(environmental_var_stack_2020s_Access_ssp126, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2020s_Access_ssp126_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2020 Access ssp126", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir2 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2020s/ssp126/range/plus_landcover"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir2)) {
      dir.create(output_dir2, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2020s_Access_ssp126_i_px)) {
      if (!is.null(species_2020s_Access_ssp126_i_px[[k]])) {
        # Define the file path for each fold
        file_path2 <- paste0(output_dir2, "habitat_suitability_species_2020s_Access_ssp126_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2020s_Access_ssp126_i_px[[k]], filename = file_path2, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path2, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices1 <- which(!sapply(species_2020s_Access_ssp126_i_px, is.null))
    species_i_px_valid1 <- species_2020s_Access_ssp126_i_px[valid_indices1]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid1 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid1 <- rep(auc_weights_valid1, length(valid_indices1))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2020s_Access_ssp126_i_px_stack <- rast(species_i_px_valid1)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2020s_Access_ssp126_i_px_stack) == 1) {
      species_2020s_Access_ssp126_i_px_avg <- species_2020s_Access_ssp126_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2020s_Access_ssp126_i_px_avg <- app(species_2020s_Access_ssp126_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid1, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2020s_Access_ssp126_i_px_avg, main = paste("Average Habitat Suitability 2020s Access ssp126", scientific_name_i))
    
    
    species_2020s_Access_ssp126_predictions_avg <- list()
    species_2020s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp126_i_px_avg
    names(species_2020s_Access_ssp126_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir3 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2020s/ssp126/average/range/plus_landcover/"
    avg_suitability_path3 <- file.path(output_dir3, paste0("weighted_avg_habitat_suitability_2020s_Access_ssp126_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2020s_Access_ssp126_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2020s_Access_ssp126_i_px_avg, filename = avg_suitability_path3, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2020s Access ssp126 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2020s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp126_i_px_avg
      
    } else {
      cat("species_2020s_Access_ssp126_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2020s_Access_ssp126 <- species_2020s_Access_ssp126_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2020s_Access_ssp126, main = paste("Binary Suitability 2020s Access ssp126 for", scientific_name_i))
      
      species_dir1 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2020s/ssp126/binary/range/plus_landcover", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir1, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary1 <- file.path(species_dir1, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2020s_Access_ssp126.tif"))
      writeRaster(
        species_i_binary_2020s_Access_ssp126,
        filename = binary1,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    
    # ---------2021-2040-ssp245-------------
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2020s_Access_ssp245 <- raster::stack( EMT_2020_ssp245, 
                                                                  EXT_2020_ssp245,
                                                                  PPT_at_2020_ssp245,
                                                                  PPT_sm_2020_ssp245,
                                                                  PPT_wt_2020_ssp245,
                                                                  elevation, slope,
                                                                  water_r_2020_ssp245, forest_r_2020_ssp245, 
                                                                  wetland_r_2020_ssp245, cropland_r_2020_ssp245, 
                                                                  grassland_r_2020_ssp245, urban_rescaled_2020_ssp245)
    environmental_var_stack_2020s_Access_ssp245
    
    plot(environmental_var_stack_2020s_Access_ssp245)
    
    
    names(environmental_var_stack_2020s_Access_ssp245) <- c(
      "EMT", "EXT", "PPT_at", "PPT_sm",
      "PPT_wt", "elevation", "slope", "water", "forest","wetland", 
      "cropland", "grassland", "urban"
    )
  
    
    environmental_var_stack_2020s_Access_ssp245 <- terra::rast(environmental_var_stack_2020s_Access_ssp245)
    
    # Apply crop and mask to match study extent and remove irrelevant areas
    environmental_var_stack_2020s_Access_ssp245 <- environmental_var_stack_2020s_Access_ssp245 %>%
      terra::crop(environmental_var_stack_i) %>%
      terra::mask(environmental_var_stack_i)
    
  
    species_2020s_Access_ssp245_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2020s_Access_ssp245_i_px[[k]] <- predict(environmental_var_stack_2020s_Access_ssp245, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2020s_Access_ssp245_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2030 Access ssp245", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir22 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2020s/ssp245/range/plus_landcover"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir22)) {
      dir.create(output_dir22, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2020s_Access_ssp245_i_px)) {
      if (!is.null(species_2020s_Access_ssp245_i_px[[k]])) {
        # Define the file path for each fold
        file_path22 <- paste0(output_dir22, "habitat_suitability_species_2020s_Access_ssp245_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2020s_Access_ssp245_i_px[[k]], filename = file_path22, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path22, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2020s_ssp245 <- which(!sapply(species_2020s_Access_ssp245_i_px, is.null))
    species_i_px_valid_2020s_ssp245 <- species_2020s_Access_ssp245_i_px[valid_indices_2020s_ssp245]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid2 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid2 <- rep(auc_weights_valid2, length(valid_indices_2020s_ssp245))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2020s_Access_ssp245_i_px_stack <- rast(species_i_px_valid_2020s_ssp245)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2020s_Access_ssp245_i_px_stack) == 1) {
      species_2020s_Access_ssp245_i_px_avg <- species_2020s_Access_ssp245_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2020s_Access_ssp245_i_px_avg <- app(species_2020s_Access_ssp245_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid2, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2020s_Access_ssp245_i_px_avg, main = paste("Average Habitat Suitability 2020s Access ssp245", scientific_name_i))
    
    
    species_2020s_Access_ssp245_predictions_avg <- list()
    species_2020s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp245_i_px_avg
    names(species_2020s_Access_ssp245_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir33 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2020s/ssp245/average/range/plus_landcover/"
    avg_suitability_path33 <- file.path(output_dir33, paste0("weighted_avg_habitat_suitability_2020s_Access_ssp245_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2020s_Access_ssp245_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2020s_Access_ssp245_i_px_avg, filename = avg_suitability_path33, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2020s Access ssp245 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2020s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp245_i_px_avg
      
    } else {
      cat("species_2020s_Access_ssp245_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2020s_Access_ssp245 <- species_2020s_Access_ssp245_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2020s_Access_ssp245, main = paste("Binary Suitability 2020s Access ssp245 for", scientific_name_i))
      
      species_dir2 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2020s/ssp245/binary/range/plus_landcover", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir2, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path33 <- file.path(species_dir2, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2020s_Access_ssp245.tif"))
      writeRaster(
        species_i_binary_2020s_Access_ssp245,
        filename = binary_path33,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    # ---------2021-2040-ssp585-------------
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2020s_Access_ssp585 <- raster::stack( EMT_2020_ssp585, 
                                                                  EXT_2020_ssp585,
                                                                  PPT_at_2020_ssp585,
                                                                  PPT_sm_2020_ssp585,
                                                                  PPT_wt_2020_ssp585,
                                                                  elevation, slope,
                                                                  water_r_2020_ssp585, forest_r_2020_ssp585, 
                                                                  wetland_r_2020_ssp585, cropland_r_2020_ssp585, 
                                                                  grassland_r_2020_ssp585, urban_rescaled_2020_ssp585)
    environmental_var_stack_2020s_Access_ssp585
    
    plot(environmental_var_stack_2020s_Access_ssp585)
    
    
    names(environmental_var_stack_2020s_Access_ssp585) <- c(
      "EMT", "EXT", "PPT_at", "PPT_sm",
      "PPT_wt", "elevation", "slope", "water", "forest","wetland", 
      "cropland", "grassland", "urban"
    )
    
    environmental_var_stack_2020s_Access_ssp585 <- terra::rast(environmental_var_stack_2020s_Access_ssp585)
    
    # Apply crop and mask to match study extent and remove irrelevant areas
    environmental_var_stack_2020s_Access_ssp585 <- environmental_var_stack_2020s_Access_ssp585 %>%
      terra::crop(environmental_var_stack_i) %>%
      terra::mask(environmental_var_stack_i)
    
    species_2020s_Access_ssp585_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2020s_Access_ssp585_i_px[[k]] <- predict(environmental_var_stack_2020s_Access_ssp585, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2020s_Access_ssp585_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2020 Access ssp585", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir222 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2020s/ssp585/range/plus_landcover"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir222)) {
      dir.create(output_dir222, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2020s_Access_ssp585_i_px)) {
      if (!is.null(species_2020s_Access_ssp585_i_px[[k]])) {
        # Define the file path for each fold
        file_path222 <- paste0(output_dir222, "habitat_suitability_species_2020s_Access_ssp585_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2020s_Access_ssp585_i_px[[k]], filename = file_path222, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path222, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2020s_ssp585 <- which(!sapply(species_2020s_Access_ssp585_i_px, is.null))
    species_i_px_valid_2020s_ssp585 <- species_2020s_Access_ssp585_i_px[valid_indices_2020s_ssp585]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid3 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid3 <- rep(auc_weights_valid3, length(valid_indices_2020s_ssp585))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2020s_Access_ssp585_i_px_stack <- rast(species_i_px_valid_2020s_ssp585)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2020s_Access_ssp585_i_px_stack) == 1) {
      species_2020s_Access_ssp585_i_px_avg <- species_2020s_Access_ssp585_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2020s_Access_ssp585_i_px_avg <- app(species_2020s_Access_ssp585_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid3, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2020s_Access_ssp585_i_px_avg, main = paste("Average Habitat Suitability 2020s Access ssp585", scientific_name_i))
    
    
    species_2020s_Access_ssp585_predictions_avg <- list()
    species_2020s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp585_i_px_avg
    names(species_2020s_Access_ssp585_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir333 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2020s/ssp585/average/range/plus_landcover/"
    avg_suitability_path333 <- file.path(output_dir333, paste0("weighted_avg_habitat_suitability_2020s_Access_ssp585_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2020s_Access_ssp585_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2020s_Access_ssp585_i_px_avg, filename = avg_suitability_path333, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2020s Access ssp585 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2020s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp585_i_px_avg
      
    } else {
      cat("species_2020s_Access_ssp585_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2020s_Access_ssp585 <- species_2020s_Access_ssp585_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2020s_Access_ssp585, main = paste("Binary Suitability 2030s Access ssp585 for", scientific_name_i))
      
      species_dir3 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2020s/ssp585/binary/range/plus_landcover", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir3, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path333 <- file.path(species_dir3, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2020s_Access_ssp585.tif"))
      writeRaster(
        species_i_binary_2020s_Access_ssp585,
        filename = binary_path333,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    # B. ---------2041-2060-------------
    
    #------------2041-2060_ssp126--------------
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2050s_Access_ssp126 <- raster::stack( EMT_2050_ssp126, 
                                                                  EXT_2050_ssp126,
                                                                  PPT_at_2050_ssp126,
                                                                  PPT_sm_2050_ssp126,
                                                                  PPT_wt_2050_ssp126,
                                                                  elevation, slope,
                                                                  water_r_2050_ssp126, forest_r_2050_ssp126, 
                                                                  wetland_r_2050_ssp126, cropland_r_2050_ssp126, 
                                                                  grassland_r_2050_ssp126, urban_rescaled_2050_ssp126)
    environmental_var_stack_2050s_Access_ssp126
    
    plot(environmental_var_stack_2050s_Access_ssp126)
    
    
    names(environmental_var_stack_2050s_Access_ssp126) <- c(
      "EMT", "EXT", "PPT_at", "PPT_sm",
      "PPT_wt", "elevation", "slope", "water", "forest","wetland", 
      "cropland", "grassland", "urban"
    )
    
    environmental_var_stack_2050s_Access_ssp126 <- terra::rast(environmental_var_stack_2050s_Access_ssp126)
    
    # Apply crop and mask to match study extent and remove irrelevant areas
    environmental_var_stack_2050s_Access_ssp126 <- environmental_var_stack_2050s_Access_ssp126 %>%
      terra::crop(environmental_var_stack_i) %>%
      terra::mask(environmental_var_stack_i)
    
    species_2050s_Access_ssp126_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2050s_Access_ssp126_i_px[[k]] <- predict(environmental_var_stack_2050s_Access_ssp126, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2050s_Access_ssp126_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2050 Access ssp126", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir4 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2050s/ssp126/range/plus_landcover"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir4)) {
      dir.create(output_dir4, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2050s_Access_ssp126_i_px)) {
      if (!is.null(species_2050s_Access_ssp126_i_px[[k]])) {
        # Define the file path for each fold
        file_path4 <- paste0(output_dir4, "habitat_suitability_species_2050s_Access_ssp126_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2050s_Access_ssp126_i_px[[k]], filename = file_path4, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path4, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices4 <- which(!sapply(species_2050s_Access_ssp126_i_px, is.null))
    species_i_px_valid4 <- species_2050s_Access_ssp126_i_px[valid_indices4]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid4 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid4 <- rep(auc_weights_valid4, length(valid_indices4))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2050s_Access_ssp126_i_px_stack <- rast(species_i_px_valid4)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2050s_Access_ssp126_i_px_stack) == 1) {
      species_2050s_Access_ssp126_i_px_avg <- species_2050s_Access_ssp126_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2050s_Access_ssp126_i_px_avg <- app(species_2050s_Access_ssp126_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid4, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2050s_Access_ssp126_i_px_avg, main = paste("Average Habitat Suitability 2050s Access ssp126", scientific_name_i))
    
    
    #species_predictions_avg <- list()
    species_2050s_Access_ssp126_predictions_avg <- list()
    species_2050s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp126_i_px_avg
    names(species_2050s_Access_ssp126_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir4 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2050s/ssp126/average/range/plus_landcover/"
    avg_suitability_path4 <- file.path(output_dir4, paste0("weighted_avg_habitat_suitability_2050s_Access_ssp126_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2050s_Access_ssp126_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2050s_Access_ssp126_i_px_avg, filename = avg_suitability_path4, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2050s Access ssp126 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2050s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp126_i_px_avg
      
    } else {
      cat("species_2050s_Access_ssp126_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2050s_Access_ssp126 <- species_2050s_Access_ssp126_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2050s_Access_ssp126, main = paste("Binary Suitability 2050s Access ssp126 for", scientific_name_i))
      
      species_dir31 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2050s/ssp126/binary/range/plus_landcover", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir31, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path4 <- file.path(species_dir31, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2050s_Access_ssp126.tif"))
      writeRaster(
        species_i_binary_2050s_Access_ssp126,
        filename = binary_path4,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    
    # ---------2041-2060-ssp245-------------
  
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2050s_Access_ssp245 <- raster::stack( EMT_2050_ssp245, 
                                                                  EXT_2050_ssp245,
                                                                  PPT_at_2050_ssp245,
                                                                  PPT_sm_2050_ssp245,
                                                                  PPT_wt_2050_ssp245,
                                                                  elevation, slope,
                                                                  water_r_2050_ssp245, forest_r_2050_ssp245, 
                                                                  wetland_r_2050_ssp245, cropland_r_2050_ssp245, 
                                                                  grassland_r_2050_ssp245, urban_rescaled_2050_ssp245)
    environmental_var_stack_2050s_Access_ssp245
    
    plot(environmental_var_stack_2050s_Access_ssp245)
    
    
    names(environmental_var_stack_2050s_Access_ssp245) <- c(
      "EMT", "EXT", "PPT_at", "PPT_sm",
      "PPT_wt", "elevation", "slope", "water", "forest","wetland", 
      "cropland", "grassland", "urban"
    )
    
    environmental_var_stack_2050s_Access_ssp245 <- terra::rast(environmental_var_stack_2050s_Access_ssp245)
    
    # Apply crop and mask to match study extent and remove irrelevant areas
    environmental_var_stack_2050s_Access_ssp245 <- environmental_var_stack_2050s_Access_ssp245 %>%
      terra::crop(environmental_var_stack_i) %>%
      terra::mask(environmental_var_stack_i)
    
    species_2050s_Access_ssp245_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2050s_Access_ssp245_i_px[[k]] <- predict(environmental_var_stack_2050s_Access_ssp245, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2050s_Access_ssp245_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2050 Access ssp245", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir44 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2050s/ssp245/range/plus_landcover"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir44)) {
      dir.create(output_dir44, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2050s_Access_ssp245_i_px)) {
      if (!is.null(species_2050s_Access_ssp245_i_px[[k]])) {
        # Define the file path for each fold
        file_path44 <- paste0(output_dir44, "habitat_suitability_species_2050s_Access_ssp245_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2050s_Access_ssp245_i_px[[k]], filename = file_path44, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path44, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2050s_ssp245 <- which(!sapply(species_2050s_Access_ssp245_i_px, is.null))
    species_i_px_valid_2050s_ssp245 <- species_2050s_Access_ssp245_i_px[valid_indices_2050s_ssp245]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid44 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid44 <- rep(auc_weights_valid44, length(valid_indices_2050s_ssp245))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2050s_Access_ssp245_i_px_stack <- rast(species_i_px_valid_2050s_ssp245)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2050s_Access_ssp245_i_px_stack) == 1) {
      species_2050s_Access_ssp245_i_px_avg <- species_2050s_Access_ssp245_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2050s_Access_ssp245_i_px_avg <- app(species_2050s_Access_ssp245_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid44, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2050s_Access_ssp245_i_px_avg, main = paste("Average Habitat Suitability 2050s Access ssp245", scientific_name_i))
    
    
    species_2050s_Access_ssp245_predictions_avg <- list()
    species_2050s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp245_i_px_avg
    names(species_2050s_Access_ssp245_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir444 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2050s/ssp245/average/range/plus_landcover/"
    avg_suitability_path444 <- file.path(output_dir444, paste0("weighted_avg_habitat_suitability_2050s_Access_ssp245_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2050s_Access_ssp245_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2050s_Access_ssp245_i_px_avg, filename = avg_suitability_path444, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2050s Access ssp245 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2050s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp245_i_px_avg
      
    } else {
      cat("species_2050s_Access_ssp245_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2050s_Access_ssp245 <- species_2050s_Access_ssp245_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2050s_Access_ssp245, main = paste("Binary Suitability 2050s Access ssp245 for", scientific_name_i))
      
      species_dir4 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2050s/ssp245/binary/range/plus_landcover", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir4, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path444 <- file.path(species_dir4, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2050s_Access_ssp126.tif"))
      writeRaster(
        species_i_binary_2050s_Access_ssp245,
        filename = binary_path444,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    # ---------2041-2060-ssp585-------------
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2050s_Access_ssp585 <- raster::stack( EMT_2050_ssp585, 
                                                                  EXT_2050_ssp585,
                                                                  PPT_at_2050_ssp585,
                                                                  PPT_sm_2050_ssp585,
                                                                  PPT_wt_2050_ssp585,
                                                                  elevation, slope,
                                                                  water_r_2050_ssp585, forest_r_2050_ssp585, 
                                                                  wetland_r_2050_ssp585, cropland_r_2050_ssp585, 
                                                                  grassland_r_2050_ssp585, urban_rescaled_2050_ssp585)
    environmental_var_stack_2050s_Access_ssp585
    
    plot(environmental_var_stack_2050s_Access_ssp585)
    
    
    names(environmental_var_stack_2050s_Access_ssp585) <- c(
      "EMT", "EXT", "PPT_at", "PPT_sm",
      "PPT_wt", "elevation", "slope", "water", "forest","wetland", 
      "cropland", "grassland", "urban"
    )
    
    environmental_var_stack_2050s_Access_ssp585 <- terra::rast(environmental_var_stack_2050s_Access_ssp585)
    
    # Apply crop and mask to match study extent and remove irrelevant areas
    environmental_var_stack_2050s_Access_ssp585 <- environmental_var_stack_2050s_Access_ssp585 %>%
      terra::crop(environmental_var_stack_i) %>%
      terra::mask(environmental_var_stack_i)
    
    species_2050s_Access_ssp585_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2050s_Access_ssp585_i_px[[k]] <- predict(environmental_var_stack_2050s_Access_ssp585, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2050s_Access_ssp585_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2030 Access ssp585", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir5 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2050s/ssp585/range/plus_landcover"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir5)) {
      dir.create(output_dir5, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2050s_Access_ssp585_i_px)) {
      if (!is.null(species_2050s_Access_ssp585_i_px[[k]])) {
        # Define the file path for each fold
        file_path5 <- paste0(output_dir5, "habitat_suitability_species_2050s_Access_ssp585_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2050s_Access_ssp585_i_px[[k]], filename = file_path5, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path5, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2050s_ssp585 <- which(!sapply(species_2050s_Access_ssp585_i_px, is.null))
    species_i_px_valid_2050s_ssp585 <- species_2050s_Access_ssp585_i_px[valid_indices_2050s_ssp585]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid5 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid5 <- rep(auc_weights_valid5, length(valid_indices_2050s_ssp585))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2050s_Access_ssp585_i_px_stack <- rast(species_i_px_valid_2050s_ssp585)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2050s_Access_ssp585_i_px_stack) == 1) {
      species_2050s_Access_ssp585_i_px_avg <- species_2050s_Access_ssp585_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2050s_Access_ssp585_i_px_avg <- app(species_2050s_Access_ssp585_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid5, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2050s_Access_ssp585_i_px_avg, main = paste("Average Habitat Suitability 2050s Access ssp585", scientific_name_i))
    
    
    species_2050s_Access_ssp585_predictions_avg <- list()
    species_2050s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp585_i_px_avg
    names(species_2050s_Access_ssp585_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir55 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2050s/ssp585/average/range/plus_landcover/"
    avg_suitability_path55 <- file.path(output_dir55, paste0("weighted_avg_habitat_suitability_2050s_Access_ssp585_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2050s_Access_ssp585_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2050s_Access_ssp585_i_px_avg, filename = avg_suitability_path55, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2050s Access ssp585 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2050s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp585_i_px_avg
      
    } else {
      cat("species_2050s_Access_ssp585_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2050s_Access_ssp585 <- species_2050s_Access_ssp585_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2050s_Access_ssp585, main = paste("Binary Suitability 2050s Access ssp585 for", scientific_name_i))
      
      species_dir5 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2050s/ssp585/binary/range/plus_landcover", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir5, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path55 <- file.path(species_dir5, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2050s_Access_ssp585.tif"))
      writeRaster(
        species_i_binary_2050s_Access_ssp585,
        filename = binary_path55,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    # C. ---------2061-2080-------------
    
    #------------2061-2080_ssp126--------------
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2070s_Access_ssp126 <- raster::stack( EMT_2080_ssp126, 
                                                                  EXT_2080_ssp126,
                                                                  PPT_at_2080_ssp126,
                                                                  PPT_sm_2080_ssp126,
                                                                  PPT_wt_2080_ssp126,
                                                                  elevation, slope,
                                                                  water_r_2080_ssp126, forest_r_2080_ssp126, 
                                                                  wetland_r_2080_ssp126, cropland_r_2080_ssp126, 
                                                                  grassland_r_2080_ssp126, urban_rescaled_2080_ssp126)
    environmental_var_stack_2070s_Access_ssp126
    
    plot(environmental_var_stack_2070s_Access_ssp126)
    
    
    names(environmental_var_stack_2070s_Access_ssp126) <- c(
      "EMT", "EXT", "PPT_at", "PPT_sm",
      "PPT_wt", "elevation", "slope", "water", "forest","wetland", 
      "cropland", "grassland", "urban"
    )
    
    environmental_var_stack_2070s_Access_ssp126 <- terra::rast(environmental_var_stack_2070s_Access_ssp126)
    
    # Apply crop and mask to match study extent and remove irrelevant areas
    environmental_var_stack_2070s_Access_ssp126 <- environmental_var_stack_2070s_Access_ssp126 %>%
      terra::crop(environmental_var_stack_i) %>%
      terra::mask(environmental_var_stack_i)
    
    species_2070s_Access_ssp126_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2070s_Access_ssp126_i_px[[k]] <- predict(environmental_var_stack_2070s_Access_ssp126, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2070s_Access_ssp126_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2070 Access ssp126", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir6 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2070s/ssp126/range/plus_landcover"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir6)) {
      dir.create(output_dir6, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2070s_Access_ssp126_i_px)) {
      if (!is.null(species_2070s_Access_ssp126_i_px[[k]])) {
        # Define the file path for each fold
        file_path6 <- paste0(output_dir6, "habitat_suitability_species_2070s_Access_ssp126_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2070s_Access_ssp126_i_px[[k]], filename = file_path6, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path6, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices6 <- which(!sapply(species_2070s_Access_ssp126_i_px, is.null))
    species_i_px_valid6 <- species_2070s_Access_ssp126_i_px[valid_indices6]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid6 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid6 <- rep(auc_weights_valid6, length(valid_indices6))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2070s_Access_ssp126_i_px_stack <- rast(species_i_px_valid6)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2070s_Access_ssp126_i_px_stack) == 1) {
      species_2070s_Access_ssp126_i_px_avg <- species_2070s_Access_ssp126_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2070s_Access_ssp126_i_px_avg <- app(species_2070s_Access_ssp126_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid6, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2070s_Access_ssp126_i_px_avg, main = paste("Average Habitat Suitability 2070s Access ssp126", scientific_name_i))
    
    
    species_2070s_Access_ssp126_predictions_avg <- list()
    species_2070s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp126_i_px_avg
    names(species_2070s_Access_ssp126_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir66 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2070s/ssp126/average/range/plus_landcover/"
    avg_suitability_path66 <- file.path(output_dir66, paste0("weighted_avg_habitat_suitability_2070s_Access_ssp126_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2070s_Access_ssp126_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2070s_Access_ssp126_i_px_avg, filename = avg_suitability_path66, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2070s Access ssp126 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2070s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp126_i_px_avg
      
    } else {
      cat("species_2070s_Access_ssp126_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2070s_Access_ssp126 <- species_2070s_Access_ssp126_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2070s_Access_ssp126, main = paste("Binary Suitability 2070s Access ssp126 for", scientific_name_i))
      
      species_dir6 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2070s/ssp126/binary/range/plus_landcover", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir6, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path66 <- file.path(species_dir6, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2070s_Access_ssp126.tif"))
      writeRaster(
        species_i_binary_2070s_Access_ssp126,
        filename = binary_path66,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    # ---------2061-2080-ssp245-------------
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2070s_Access_ssp245 <- raster::stack( EMT_2080_ssp245, 
                                                                  EXT_2080_ssp245,
                                                                  PPT_at_2080_ssp245,
                                                                  PPT_sm_2080_ssp245,
                                                                  PPT_wt_2080_ssp245,
                                                                  elevation, slope,
                                                                  water_r_2080_ssp245, forest_r_2080_ssp245, 
                                                                  wetland_r_2080_ssp245, cropland_r_2080_ssp245, 
                                                                  grassland_r_2080_ssp245, urban_rescaled_2080_ssp245)
    environmental_var_stack_2070s_Access_ssp245
    
    plot(environmental_var_stack_2070s_Access_ssp245)
    
    
    names(environmental_var_stack_2070s_Access_ssp245) <- c(
      "EMT", "EXT", "PPT_at", "PPT_sm",
      "PPT_wt", "elevation", "slope", "water", "forest","wetland", 
      "cropland", "grassland", "urban"
    )
    
    environmental_var_stack_2070s_Access_ssp245 <- terra::rast(environmental_var_stack_2070s_Access_ssp245)
    
    # Apply crop and mask to match study extent and remove irrelevant areas
    environmental_var_stack_2070s_Access_ssp245 <- environmental_var_stack_2070s_Access_ssp245 %>%
      terra::crop(environmental_var_stack_i) %>%
      terra::mask(environmental_var_stack_i)
    
    species_2070s_Access_ssp245_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2070s_Access_ssp245_i_px[[k]] <- predict(environmental_var_stack_2070s_Access_ssp245, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2070s_Access_ssp245_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2070 Access ssp245", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir7 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2070s/ssp245/range/plus_landcover"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir7)) {
      dir.create(output_dir7, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2070s_Access_ssp245_i_px)) {
      if (!is.null(species_2070s_Access_ssp245_i_px[[k]])) {
        # Define the file path for each fold
        file_path7 <- paste0(output_dir7, "habitat_suitability_species_2070s_Access_ssp245_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2070s_Access_ssp245_i_px[[k]], filename = file_path7, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path7, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2070s_ssp245 <- which(!sapply(species_2070s_Access_ssp245_i_px, is.null))
    species_i_px_valid_2070s_ssp245 <- species_2070s_Access_ssp245_i_px[valid_indices_2070s_ssp245]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid77 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid77 <- rep(auc_weights_valid77, length(valid_indices_2070s_ssp245))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2070s_Access_ssp245_i_px_stack <- rast(species_i_px_valid_2070s_ssp245)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2070s_Access_ssp245_i_px_stack) == 1) {
      species_2070s_Access_ssp245_i_px_avg <- species_2070s_Access_ssp245_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2070s_Access_ssp245_i_px_avg <- app(species_2070s_Access_ssp245_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid77, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2070s_Access_ssp245_i_px_avg, main = paste("Average Habitat Suitability 2070s Access ssp245", scientific_name_i))
    
    
    species_2070s_Access_ssp245_predictions_avg <- list()
    species_2070s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp245_i_px_avg
    names(species_2070s_Access_ssp245_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir77 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2070s/ssp245/average/range/plus_landcover/"
    avg_suitability_path77 <- file.path(output_dir77, paste0("weighted_avg_habitat_suitability_2070s_Access_ssp245_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2070s_Access_ssp245_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2070s_Access_ssp245_i_px_avg, filename = avg_suitability_path77, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2070s Access ssp245 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2070s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp245_i_px_avg
      
    } else {
      cat("species_2070s_Access_ssp245_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2070s_Access_ssp245 <- species_2070s_Access_ssp245_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2070s_Access_ssp245, main = paste("Binary Suitability 2070s Access ssp245 for", scientific_name_i))
      
      species_dir7 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2070s/ssp245/binary/range/plus_landcover", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir7, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path77 <- file.path(species_dir7, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2070s_Access_ssp245.tif"))
      writeRaster(
        species_i_binary_2070s_Access_ssp245,
        filename = binary_path77,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    # ---------2061-2080-ssp585-------------
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2070s_Access_ssp585 <- raster::stack( EMT_2080_ssp585, 
                                                                  EXT_2080_ssp585,
                                                                  PPT_at_2080_ssp585,
                                                                  PPT_sm_2080_ssp585,
                                                                  PPT_wt_2080_ssp585,
                                                                  elevation, slope,
                                                                  water_r_2080_ssp585, forest_r_2080_ssp585, 
                                                                  wetland_r_2080_ssp585, cropland_r_2080_ssp585, 
                                                                  grassland_r_2080_ssp585, urban_rescaled_2080_ssp585)
    environmental_var_stack_2070s_Access_ssp585
    
    plot(environmental_var_stack_2070s_Access_ssp585)
    
    
    names(environmental_var_stack_2070s_Access_ssp585) <- c(
      "EMT", "EXT", "PPT_at", "PPT_sm",
      "PPT_wt", "elevation", "slope", "water", "forest","wetland", 
      "cropland", "grassland", "urban"
    )
    
    environmental_var_stack_2070s_Access_ssp585 <- terra::rast(environmental_var_stack_2070s_Access_ssp585)
    
    # Apply crop and mask to match study extent and remove irrelevant areas
    environmental_var_stack_2070s_Access_ssp585 <- environmental_var_stack_2070s_Access_ssp585 %>%
      terra::crop(environmental_var_stack_i) %>%
      terra::mask(environmental_var_stack_i)
    
    species_2070s_Access_ssp585_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2070s_Access_ssp585_i_px[[k]] <- predict(environmental_var_stack_2070s_Access_ssp585, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2070s_Access_ssp585_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2070 Access ssp585", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir8 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2070s/ssp585/range/plus_landcover"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir8)) {
      dir.create(output_dir8, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2070s_Access_ssp585_i_px)) {
      if (!is.null(species_2070s_Access_ssp585_i_px[[k]])) {
        # Define the file path for each fold
        file_path8 <- paste0(output_dir8, "habitat_suitability_species_2070s_Access_ssp585_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2070s_Access_ssp585_i_px[[k]], filename = file_path8, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path8, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2070s_ssp585 <- which(!sapply(species_2070s_Access_ssp585_i_px, is.null))
    species_i_px_valid_2070s_ssp585 <- species_2070s_Access_ssp585_i_px[valid_indices_2070s_ssp585]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid8 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid8 <- rep(auc_weights_valid8, length(valid_indices_2070s_ssp585))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2070s_Access_ssp585_i_px_stack <- rast(species_i_px_valid_2070s_ssp585)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2070s_Access_ssp585_i_px_stack) == 1) {
      species_2070s_Access_ssp585_i_px_avg <- species_2070s_Access_ssp585_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2070s_Access_ssp585_i_px_avg <- app(species_2070s_Access_ssp585_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid8, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2070s_Access_ssp585_i_px_avg, main = paste("Average Habitat Suitability 2070s Access ssp585", scientific_name_i))
    
    
    species_2070s_Access_ssp585_predictions_avg <- list()
    species_2070s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp585_i_px_avg
    names(species_2070s_Access_ssp585_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir88 <- "F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2070s/ssp585/average/range/plus_landcover/"
    avg_suitability_path88 <- file.path(output_dir88, paste0("weighted_avg_habitat_suitability_2070s_Access_ssp585_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2070s_Access_ssp585_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2070s_Access_ssp585_i_px_avg, filename = avg_suitability_path88, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2070s Access ssp585 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2070s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp585_i_px_avg
      
    } else {
      cat("species_2070s_Access_ssp585_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2070s_Access_ssp585 <- species_2070s_Access_ssp585_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2070s_Access_ssp585, main = paste("Binary Suitability 2070s Access ssp585 for", scientific_name_i))
      
      species_dir8 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/amphibians/amphibians_future/2070s/ssp585/binary/range/plus_landcover", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir8, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path88 <- file.path(species_dir8, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2070s_Access_ssp585.tif"))
      writeRaster(
        species_i_binary_2070s_Access_ssp585,
        filename = binary_path88,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
  }}








# --------------------Repeat code for reptiles-------------------


# load historical climate data
DD0 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_DD0.tif")
DD0
EXT <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_EXT.tif")
EXT
PPT_at <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_PPT_at.tif")
PPT_sm <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_PPT_sm.tif")
PPT_wt <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_PPT_wt.tif")


# Stack all environmental rasters (raster stack)
environmental_var_stack <- raster::stack(DD0, EXT, PPT_at, PPT_sm, PPT_wt)
environmental_var_stack

plot(environmental_var_stack)


names(environmental_var_stack) <- c(
  "DD0",
  "EXT",
  "PPT_at",
  "PPT_sm",
  "PPT_wt"
)


na_check <- sapply(1:nlayers(environmental_var_stack), function(i) {
  sum(is.na(values(environmental_var_stack[[i]])))
})
names(na_check) <- names(environmental_var_stack)
na_check

plot(is.na(environmental_var_stack[[1]]), main = "NA areas in BIO4")


# Read study area 
shapefile_path <- "F:/Uillinois_data/study_area/study_area_projected.shp"
studyarea <- st_read(shapefile_path)  # Path to your study area shapefile

study_area <- studyarea %>%
  # Transform the CRS of the ppr_region to match that of environmental variables(environmental_var_stack)
  st_transform(crs = crs(environmental_var_stack)) %>%
  # Remove the Z dimension, if present
  st_zm() %>%
  # Convert sf (simple feature) to sp (spatial) object
  as_Spatial()

plot(DD0)
plot(study_area, add = TRUE, border = "red", lwd = 2)


##3. Second step is to load species list and observations 

# I start by loading the csv file that contains the list of all species for the prairie region, filter and modify the data, and adds columns for model performance and environmental variables
modelPerformanceAllSpecies <- read.csv("F:/Uillinois_data/analysis/habitat_suitability/MWCASCBiodiversityAllSpecies_reptile1.csv") %>%
  filter(n_MWCASC > 20) %>% # this code filters and keep rows where the n_SECanada column has  20 observation records or more. 20 records is the minimum threshold required for fitting models for the SE Canada region
  dplyr::select(-X) %>%
  # the below code adds to two columns with variables mean_auc and mean_threshold, initialized with a NA value in inorder to store future model performance values
  mutate(mean_auc = NA,
         mean_threshold = NA) %>%
  # add blank columns for mean species values of each environmental variable, and filling them with NA values
  cbind(., t(rep(NA,length(names(environmental_var_stack)))))

dim(modelPerformanceAllSpecies)  # checks the number of rows and columns in the species list
head(modelPerformanceAllSpecies)# checks some few rows to see how the data looks like with the columns added
View(modelPerformanceAllSpecies)

#add environmental variable names to data frame
# the code below retrieves and adds new columns to the modelPerformanceAllSpecies file, with names of each environmental variable in the raster stack, starting from the 8th column to the last column (ncol(modelPerformanceAllSpecies))
names(modelPerformanceAllSpecies)[8:ncol(modelPerformanceAllSpecies)] <- names(environmental_var_stack)

#Now reprint the modelPerformanceAllSpecies data to check if the environmental variables have been successfully added 
head(modelPerformanceAllSpecies)
View(modelPerformanceAllSpecies)

# Load species observation data 
reptile_observations <- read.csv("F:/Uillinois_data/analysis/habitat_suitability/reptile_observations_cleaned1.csv")

# Combine all observations
species_observations <- rbind(reptile_observations) 
head(species_observations)

# Species observations are still in dataframe format, hence, a need to convert the data frame to an sf object
species_observations_sf <- st_as_sf(
  species_observations,
  coords = c("longitude", "latitude"),
  crs = 4326,  # WGS84 coordinate reference system
  remove = FALSE  # Keeps the original longitude and latitude columns
)

# Check the structure
print(species_observations_sf)

# Reproject the sf object to the CRS of bio4 (e.g., a raster layer)
species_observations_transformed <- st_transform(species_observations_sf, crs = st_crs(environmental_var_stack))

# Remove rows where "species" column is NA
species_observations_cleaned <- species_observations_transformed[!is.na(species_observations_transformed$species), ]

# Check the result
head(species_observations_cleaned)
# Plot observation points and visualize on climate maps
plot(environmental_var_stack[[1]], main = "Reprojected & Masked Bio9 Layer")
# Add the species points
plot(species_observations_cleaned, 
     add = TRUE, 
     col = "red", 
     pch = 16)


# Step 2: Remove Z/M dimensions if present (if needed for conversion to Spatial)
species_observations_reproj <- st_zm(species_observations_cleaned)

# Get the extent of environmental_var_stack as an sf polygon
env_extent <- as(extent(environmental_var_stack), "SpatialPolygons")
crs(env_extent) <- crs(environmental_var_stack)
env_extent_sf <- st_as_sf(env_extent)

# Clip points that fall within extent
species_observations_clipped <- st_intersection(species_observations_reproj, env_extent_sf)

# Plot
plot(environmental_var_stack[[1]], main = "Clipped Species Observations on Bio4")
plot(st_geometry(species_observations_clipped), 
     add = TRUE, 
     col = "red", 
     pch = 16)


### Use loop to create raster for each taxonomic group.
# In this section, I will start by defining a group vector, by assigning the taxonomic groups that will be iterated in a loop
# Print unique names in the "group" column
unique_groups <- unique(species_observations_clipped$group)# get group names from observation data
print(unique_groups)

group_vector <- c("reptiles")

# The second stage is to Store target group Sampling raster in a list (named by taxon)
# Here, I will first create an empty list to store raster objects, that will be created as kernel density estimates for each taxonomic group
observations_kde_list <- list()

names(environmental_var_stack)


# Next, is to define resolution and extent based on environmental_mask. This will ensure that all raster layers that will be generated, will follow thesame resolution and spatial extents as those of the stacked raster layers created at the early stage (e.g., forest
# first, create an environmental mask for one of the stacked raster layer (here i use forest), which will be used in setting the desired resolution and extent for all other raster objects as i move forward
environmental_mask <- terra::rast(environmental_var_stack$DD0)
# second, I create a target resolution to be used for all raster layers as I proceed, by extracting the resolution of the masked raster layer (forest), using the terra package
target_resolution <- terra::res(environmental_mask)
# third, I also create a target extent that will be used for all raster layers to be developed, by extracting the extent of the masked raster
target_extent <- terra::ext(environmental_mask)

environmental_mask
plot(environmental_mask)
target_resolution
target_extent

for(g in group_vector){ # this function defines a loop over each element in the group_vector defined above (birds, mammals, amphibians and reptiles), where data specific to each group, g, will be processed independently in each iteration in the loop
  # after defining the loop function, the next thing is to ensure that each species observation is filtered to include only records for the group, g, with these records converted to a spatial format for further processing
  group_g_observations <- species_observations_clipped %>%
    filter(group == g) %>%
    slice_sample(n = 100000)  # for each group with filtered records, I randomly sample about 100,000 observations for producing KDE. 100,000 observations seem to be a manageable threshold record for each group in every KDE operation
  
  # Check if there are any observations to process
  if (nrow(group_g_observations) == 0) {
    message("No observations for group: ", g)
    next  # Skip to the next group if no data
  }
  summary(group_g_observations)
  
  # next, for each group observation g, convert the coordinates to simple feature feature (sf) objects using the sf package, so it becomes compatible with spatial feature functions in R
  group_g_observations_sf <- st_as_sf(group_g_observations, coords = c("longitude", "latitude"), crs = 4326) # here, I have converted the coordinates to EPSG:4326, the standard World Geodetic coordinate system 
  
  # the next thing is to project the group_g_observations_sf data to match that of the stacked environmental layers
  group_g_observations_sf <- st_transform(group_g_observations_sf, st_crs(environmental_var_stack))
  
  # I will now calculate KDE (kernel density estimates) for each group observation g, by masking the calculations (raster data) to the target resolution defined in the earlier face of the codes, using the resolution of one of the stacked predictors (forest). I am using the spatialEco package to do this
  kde_result <- spatialEco::sp.kde(
    x = group_g_observations_sf,
    res = target_resolution,   # Set KDE resolution to match environmental_mask
    standardize = TRUE #normalizes the density values to make them comparable across groups.
  )
  # Check the class of the KDE result and resample if needed
  # here, there is a need to verify is the KDE results produced are SpatRaster objects, considering that the package used now is the terra package, which has replaced the previos Rgeos package that has depreciated
  # the code therefore ensures that, If kde_result is not a SpatRaster object, then, the stop() function is executed to halt the operation and display the message "KDE result is not a SpatRaster." This ensures that only valid SpatRaster objects are processed in the next steps.
  if (!inherits(kde_result, "SpatRaster")) {
    stop("KDE result is not a SpatRaster.")
  }
  
  # After calculating the KDE for each species observation, g, there is a need ensure that the results fall within the geographic boundaries of the target extent (forest), define in the earlier stage of this script
  kde_result <- terra::crop(kde_result, environmental_mask)  # Crop to target extent using the crop function of the terra package
  kde_result <- terra::resample(kde_result, environmental_mask, method = "bilinear")  # although the target resolution has been specified in the KDE calculations, it is always a good approach to resample to target resolution again after coping the target extent. Also, the bilinear interpolation in the raster resampling, ensures that new pixel values are calculated based on the weighted average of surrounding pixels, yielding a smoother result
  
  # To ensure that there is no mismatch in spatial extents and resolutions between the calculated KDEs and masked or stacked environmental layers, there is a need to mask the KDE result with the stacked or masked environmental layer (forest)
  observations_kde_list[[g]] <- terra::mask(kde_result, environmental_mask)
}


# Plot KDE results for each group
par(mfrow = c(1, 1))  # Arrange plots in a 2x2 grid

for (g in names(observations_kde_list)) {
  plot(observations_kde_list[[g]], main = paste("KDE for", g))
}


# Set species common name: here, I extract the common name of each species in each row i (within the modelPerformanceAllSpecies csv file), and store it in a new variable called scientific_name_i, for easy reference in the loop iterations
for (i in 1:nrow(modelPerformanceAllSpecies)) {
  # Extract key species attributes
  group_i <- modelPerformanceAllSpecies$group[i]  
  genus_i <- modelPerformanceAllSpecies$genus[i]
  species_i <- modelPerformanceAllSpecies$species[i]
  scientific_name_i <- modelPerformanceAllSpecies$scientific_name[i]
  common_name_i <- modelPerformanceAllSpecies$scientific_name[i]
  
  message("\nProcessing species: ", scientific_name_i, " (", genus_i, " ", species_i, ") in group: ", group_i)
  
  # Ensure KDE raster exists for this group
  if (!group_i %in% names(observations_kde_list)) {
    message("No KDE raster available for group: ", group_i, " - Skipping species: ", scientific_name_i)
    next
  }
  observations_kde_group_i <- observations_kde_list[[group_i]]
  
  # Filter species observations
  species_i_sp <- species_observations_clipped %>%
    filter(scientific_name == scientific_name_i) %>%
    slice_sample(n = 1, by = square_id)  # Avoids spatial autocorrelation issues
  
  if (nrow(species_i_sp) == 0) {
    message("No valid occurrences found for species: ", scientific_name_i, " - Skipping.")
    next
  }
  
  # Convert species occurrence data to spatial format
  species_i_sp <- st_as_sf(species_i_sp, coords = c("longitude", "latitude"), crs = 4326)
  
  # Ensure study_area is an sf object and matches CRS
  study_area <- st_as_sf(study_area)
  
  if (st_crs(species_i_sp) != st_crs(study_area)) {
    message("Transforming CRS of study area to match species observations.")
    study_area <- st_transform(study_area, st_crs(species_i_sp))
  }
  
  # Print key elements for debugging (optional)
  print(observations_kde_group_i)
  
  # Intersect species points with the study area
  species_i_intersects_SE <- st_intersects(species_i_sp, study_area, sparse = FALSE)
  
  # Filter species points by intersection (keep only points inside the study area)
  species_i_sp <- species_i_sp[which(rowSums(species_i_intersects_SE) > 0), ]
  
  # Check if there are any remaining points after filtering
  if (nrow(species_i_sp) == 0) {
    message("No valid intersection found for species: ", scientific_name_i, " - Skipping.")
    modelPerformanceAllSpecies$n_MWCASC[i] <- 0  # Assign zero if no observations remain
    next
  }
  
  # Transform the CRS of the filtered points to match the environmental variable stack
  species_i_sp <- st_transform(species_i_sp, st_crs(environmental_var_stack))
  
  # Extract unique observation points (latitude and longitude), removing duplicate coordinates
  obs_species_i <- unique(st_coordinates(species_i_sp))
  
  # Convert the matrix of coordinates into a data frame
  obs_species_i <- data.frame(longitude = obs_species_i[, 1],
                              latitude = obs_species_i[, 2])
  
  # Check the first few records (optional for debugging)
  head(obs_species_i)
  
  # Save sample size: store the count of unique observation points in modelPerformanceAllSpecies
  modelPerformanceAllSpecies$n_MWCASC[i] <- nrow(obs_species_i)
  
  # Optional: Print progress update
  message("Processed ", nrow(obs_species_i), " unique occurrences for species: ", common_name_i)
  
  # Define output folder and create it if it doesn't exist
  output_dir_range <- "F:/Uillinois_data/analysis/habitat_suitability/species_range_reptiles"
  dir.create(output_dir_range, recursive = TRUE, showWarnings = FALSE)
  
  # Only model species with >= 20 observations
  if(modelPerformanceAllSpecies$n_MWCASC[i] >= 20){# here, i first of all check and select the number of unique observations filtered for the prairie region (n_prairie) in each row of the modelPerformanceAllSpecies data, with records  >= 20; 20 is the minimum threshold)
    # I now assign the obs_species_i data frame (which contains the unique coordinates in each grid id) into a new variable "species_i_ppr_sp", assign lon and lat coordinates to make it a spatial object, and finally project the variable to a similar CRS with the stacked environmental variables
    species_i_sp <- obs_species_i
    coordinates(species_i_sp) <- c("longitude", "latitude")
    species_i_sp@proj4string <- raster::crs(environmental_var_stack)
    
    # Generate a 50 km buffer around each observation point
    species_i_buffers <- spTransform(species_i_sp, CRS = raster::crs(environmental_var_stack)) %>%
      raster::buffer(width = 50000)  # 5 km buffer around each observation
    
    # Convert the buffer to an sf object for easier handling
    species_i_buffers_sf <- st_as_sf(species_i_buffers)
    
    # Dissolve and merge all buffers
    species_i_buffers_dissolved <- species_i_buffers_sf %>%
      st_union()  # Dissolve all buffers into a single polygon
    
    # Define species name and file path
    species_names <- modelPerformanceAllSpecies$species[i]
    shapefile_path <- file.path(output_dir_range, paste0(gsub(" ", "_", species_names), "_range.shp"))
    
    # Save the shapefile
    st_write(species_i_buffers_dissolved, shapefile_path, delete_layer = TRUE)
    
    # Plot the dissolved buffer (clipped to the study area) and the study area
    #par(mfrow = c(1, 1))  # Set up a single panel for plotting
    #plot(st_geometry(species_i_buffers_dissolved), main = "Clipped Dissolved 5 km Buffer for Fowler's Toad Observations", col = "lightblue")
    #plot(st_geometry(clipped_study_area_proj), add = TRUE, border = "black")  # Overlay study area
    
    
    ggplot() +
      geom_sf(data = study_area, fill = "gray95", color = "black") +
      geom_sf(data = st_as_sf(species_i_buffers_dissolved), color = "darkgreen", size = 2, alpha = 0.7) +
      theme_minimal() +
      labs(title = "Species Observations",
           subtitle = "Species Observations within the Study Area",
           caption = "Species observation points have been transformed to match CRS")
    
    
    # Now Calculate species range size
    species_i_rangesize <- species_i_buffers_dissolved %>% 
      st_intersection(study_area) %>%  # Intersects the species buffer with the clipped study area to remove parts outside
      st_area() %>%  # Calculates the total area of the intersected buffers
      as.numeric() %>%  # Converts the calculated area to numeric for ease of further analysis
      sum()  # Sums up areas of multiple polygons to get the total range size
    species_i_rangesize
    
    # Estimate study area size
    study_area_size <- st_area(study_area) %>% as.numeric()
    study_area_size 
    
    # Ensure the buffer has the same CRS as the environmental variable stack
    species_i_buffers_dissolved <- st_transform(species_i_buffers_dissolved, crs = st_crs(environmental_var_stack))
    
    # Convert the dissolved buffer to an sp object
    species_i_buffers_dissolved_sp <- as(species_i_buffers_dissolved, "Spatial")
    
    # Now apply the crop and mask functions
    if(species_i_rangesize >= 0.9 * 2.018284e+12){ # Use full study area if range size is >= 90% of study area
      environmental_var_stack_i <- environmental_var_stack  # Use the entire study area
    } else {
      environmental_var_stack_i <- environmental_var_stack %>%
        raster::crop(., species_i_buffers_dissolved_sp) %>%  # Crop environmental data to species' range
        raster::mask(., species_i_buffers_dissolved_sp)  # Mask environmental data to species' range
    }
    
    # Plot to visualize the environmental variable stack and buffer
    plot(environmental_var_stack_i$DD0)
    plot(species_i_buffers_dissolved, add = TRUE, lty = 5)  # Overlay species buffer on top of the environmental data
    
    # Use the full study area, regardless of the species' range size
    environmental_var_stack_i <- environmental_var_stack  # Use the entire study area
    
    # Convert species_i_sp to an sf object if it is a SpatialPointsDataFrame
    species_i_sf <- st_as_sf(species_i_sp)
    
    # Next, is to extract values of environmental_var_stack_i for all obs_species_i
    modelPerformanceAllSpecies[i,8:ncol(modelPerformanceAllSpecies)] <- raster::extract(environmental_var_stack_i,
                                                                                        species_i_sf) %>%
      # first, this code ensures that the raster values of each environmental variable (within the stacked raster) is extracted for every given location of a species, within the species observation variable, "species_i_ppr_sp".
      # through this approach, a data structure is created for each observation point, where each column represents each environmental variable, and each row represents each observation 
      as_tibble(.) %>% # here, the data structure is converted to a tibble, a modern data frame structure in R that facilitates subsequent operations
      summarize_all(., mean, na.rm = TRUE) # this operation ensures that the mean of each environmental variable is calculated across observations for the said variable, ignoring all NA values
    # In the definition,modelPerformanceAllSpecies[i, 8:ncol(modelPerformanceAllSpecies)] <- ..., the calculated means areassigned to columns 8 onward for each row, i, of the modelPerformanceAllSpecies data frame. The results of these columns are required for evaluating model performance or habitat suitability for species in subsequent analysis
    
    modelPerformanceAllSpecies[i,8:ncol(modelPerformanceAllSpecies)]
    
    # Because the environmental_var_stack_i variable created above is still working with the raster package, there is need to the data to a SpatRaster in order to avoid model fitting and evaluation errors
    environmental_var_stack_i <- terra::rast(environmental_var_stack_i)
    # after converting to a SpatRaster, we need to ensure that our species KDE calculated in th earlier stage of this analysis matches the extent and resolution of our newly created environmental_var_stack_ic SpatRaster object
    # It should be noted that KDE raster captures observation biases
    observationbias_species_i <- observations_kde_group_i %>%
      terra::crop(environmental_var_stack_i) %>%
      terra::mask(environmental_var_stack_i)
    observationbias_species_i
    
    
    # Check if the observation bias raster has any values
    plot(observationbias_species_i)
    
    # If it's empty or not valid, skip further processing for this species
    if (all(is.na(values(observationbias_species_i)))) {
      message("Observation bias is empty for species: ", scientific_name_i, " - Skipping further analysis")
    } else {
      # Plot the observation bias for species
      plot(observationbias_species_i)
    }
  }
  
  
  # Next, is to generate background points based on species range size pixels
  # However, I will first, calculate the number of pixels in the species range, using the global() function from the terra package 
  species_i_rangepixels <- global(((observationbias_species_i[[1]] * 0) + 1), 'sum', na.rm = TRUE)[1, 1]
  # Here, the observationbias_species_i[[1]] * 0 creates a raster with the same structure as observationbias_species_i but filled with zeros
  # + 1 then turns all pixel values to 1, representing each pixel as a unit.
  #global(..., 'sum', na.rm = TRUE) then sums all these pixel values, providing the count of pixels that cover the species' range
  # the [1, 1] extracts this count from the result, storing it in species_i_rangepixels.
  species_i_rangepixels
  
  # Now, determine background points based on species range size pixels
  if(species_i_rangepixels < 100000){
    # Use 20% for small ranges i.e., assign backg_n as 20% of species_i_rangepixels
    backg_n <- round(species_i_rangepixels*0.2, 0)
  }else if(species_i_rangepixels >= 100000 & species_i_rangepixels < 250000){
    # Use 10% for medium ranges i.e., assign backg_n as 10% of species_i_rangepixels
    backg_n <- round(species_i_rangepixels*0.1, 0)
  }else if(species_i_rangepixels >= 250000){
    # Use 5% for big ranges
    backg_n <- round(species_i_rangepixels*0.05, 0) #rounds the calculated value to the nearest integer for easier indexing
  }
  
  backg_n
  
  
  # Sample background points, using bias specific to a target group
  ext <- ext(observationbias_species_i)
  # Generate background points using terra::spatSample()
  backg <- terra::spatSample(observationbias_species_i, 
                             size = backg_n, method = "random", 
                             na.rm = TRUE, xy = TRUE)
  backg
  
  colnames(backg)
  
  backg <- backg[, 1:2]  # Select only the first two columns
  colnames(backg) <- c("lon", "lat")
  
  # Make one sf for background
  backg_sf <- backg %>%
    as.data.frame(.) %>%
    st_as_sf(.,
             coords = c("lon", "lat"),
             crs = raster::crs(environmental_var_stack_i)) %>%
    mutate(p = 0) %>%
    cbind(., st_coordinates(.))
  
  head(backg_sf)
  
  # Make sf object with presence and background points
  species_i_presbackg_sf <- species_i_sf %>%
    st_as_sf(., crs = raster::crs(environmental_var_stack_i)) %>%
    mutate(p = 1) %>%
    cbind(., st_coordinates(.)) %>%
    rbind(backg_sf)
  
  head(species_i_presbackg_sf)
  tail(species_i_presbackg_sf)
  
  # Make sure all points have values for each environmental variable
  species_i_pb_extract <- raster::extract(environmental_var_stack_i,
                                          species_i_presbackg_sf) %>%
    as.data.frame(.)
  
  head(species_i_pb_extract)
  #View(species_i_pb_extract)
  
  # Omit NA row names
  species_i_omit_rownames <- row.names(species_i_pb_extract[is.na(species_i_pb_extract$forest) |
                                                              is.na(species_i_pb_extract$water)|
                                                              is.na(species_i_pb_extract$wetlands)|
                                                              is.na(species_i_pb_extract$annual.croplands)|
                                                              is.na(species_i_pb_extract$barren.lands)|
                                                              is.na(species_i_pb_extract$nativegrass)|
                                                              is.na(species_i_pb_extract$perennial.croplands)|
                                                              is.na(species_i_pb_extract$roads)|
                                                              is.na(species_i_pb_extract$settlements)|
                                                              is.na(species_i_pb_extract$tmax)|
                                                              
                                                              is.na(species_i_pb_extract$prec),]) 
  
  
  # Alternative approach to omitting row names
  #species_i_omit_rownames <- rownames(species_i_pb_extract[rowSums(is.na(species_i_pb_extract[
  #c("forest", "water", "wetlands", "annual.croplands", "barren.lands",
  #"nativegrass", "perennial.croplands", "roads", "settlements",
  #"tmax", "tmin", "prec")])) > 0, ])
  
  species_i_omit_rownames
  summary(species_i_omit_rownames)
  
  
  # Define species presence/background data
  species_i_presbackg_sf <- species_i_presbackg_sf %>%
    filter(!(row.names(.) %in% species_i_omit_rownames)) # Remove rows with NA values
  
  # Run spatial blocking to prepare data for cross-validation
  sb <- spatialBlock(speciesData = species_i_presbackg_sf %>%
                       filter(!(row.names(.) %in% species_i_omit_rownames)),
                     species = "p",  # Presence column (1 for presence, 0 for background)
                     rasterLayer = environmental_var_stack_i,
                     selection = "systematic",
                     rows = 10,
                     cols = 10,  # Define the number of rows and columns in the grid
                     k = 5,  # Number of folds for cross-validation
                     biomod2Format = TRUE)  # Format compatible with biomod2 package
  
  # Add fold ID to dataset
  species_i_presbackg_sf <- species_i_presbackg_sf %>%
    filter(!(row.names(.) %in% species_i_omit_rownames)) %>%
    mutate(fold = sb$foldID)
  
  # Ensure the fold assignments are properly distributed
  table(species_i_presbackg_sf$fold)  # Check the distribution of folds
  
  # Filter out rows with missing values
  species_i_pb_extract <- species_i_pb_extract %>%
    filter(!(row.names(.) %in% species_i_omit_rownames))
  
  # Initialize evaluation metrics
  species_i_eval_summary <- data.frame(fpr = c(), tpr = c(), fold = c())
  species_i_maxent_models <- list()  # List to store Maxent models
  species_i_px <- list()  # List to store habitat suitability predictions
  AUCs_i <- vector(mode = "numeric", length = 5)  # Store AUCs for each fold
  
  # Identify folds with no observations (e.g. large range, but small clustered points like Great Plains Toad)
  species_i_foldvector <- species_i_presbackg_sf %>%
    st_drop_geometry(.) %>%
    filter(p == 1) %>%
    group_by(fold) %>%
    summarize(total = n()) %>%
    pull(fold)
  
  # Loop through folds for cross-validation
  for (k in 1:5) {
    # Split data into training and testing sets based on fold
    trainSet <- which(sb$foldID != k)
    testSet <- which(sb$foldID == k)
    
    # Check if both training and testing sets have data
    if (length(trainSet) == 0 || length(testSet) == 0) {
      cat("No observations in fold", k, ", skipping this fold.\n")
      next  # Skip this fold if no observations are available
    }
    
    
    # Check column names in the species_i_presbackg_sf to verify the existence of the 'ID' column
    cat("Column names in species_i_presbackg_sf:", colnames(species_i_presbackg_sf), "\n")
    
    # Remove the 'ID' column from the environmental and presence-background data
    # If 'ID' column exists in species_i_presbackg_sf, it will be removed
    if("ID" %in% colnames(species_i_presbackg_sf)) {
      species_i_presbackg_sf_no_ID <- species_i_presbackg_sf %>%
        st_drop_geometry() %>%
        dplyr::select(-ID)  # Remove 'ID' column from the spatial data
    } else {
      cat("'ID' column not found in species_i_presbackg_sf\n")
      species_i_presbackg_sf_no_ID <- species_i_presbackg_sf  # Keep the data as is if no 'ID' column
    }
    
    # Remove the 'ID' column from the environmental data (assuming it's named 'ID' in species_i_pb_extract)
    species_i_pb_extract_no_ID <- species_i_pb_extract[, !colnames(species_i_pb_extract) %in% "ID"]
    species_i_pb_extract_no_ID
    
    # Subset the training and testing data
    trainData <- species_i_presbackg_sf[trainSet, ]
    testData <- species_i_presbackg_sf[testSet, ]
    trainEnv <-  species_i_pb_extract_no_ID[trainSet, ]
    testEnv <-  species_i_pb_extract_no_ID[testSet, ]
    
    
    # Now, fit the MaxEnt model using linear, quadratic, and hinge features
    
    # Fit Maxent model
    species_i_maxent_model <- maxent(
      x = trainEnv,  # Environmental variables for the training set
      p = trainData$p,  # Presence data for the training set
      a = trainData$background,  # Background data for the training set
      args = c("outputformat=cloglog", "betamultiplier=1", "maximumiterations=1000")  # Maxent model arguments
    )
    
    species_i_maxent_model
    
    
    # Store the fitted Maxent model
    species_i_maxent_models[[k]] <- species_i_maxent_model 
    
    # Get variable importance from the fitted Maxent model
    # Define output directory for variable importance (if not already defined)
    variable_importance_dir <- file.path("F:/Uillinois_data/analysis/habitat_suitability/variable_importance_reptiles")
    dir.create(variable_importance_dir, recursive = TRUE, showWarnings = FALSE)
    
    # Extract variable importance for the species
    if (!is.null(species_i_maxent_model)) {
      
      # Extract variable contribution and permutation importance
      variable_importance <- species_i_maxent_model@results
      
      # Optionally: keep only relevant variable importance rows
      var_imp_rows <- grep("contribution$|permutation.importance$", rownames(variable_importance), value = TRUE)
      variable_importance_filtered <- variable_importance[var_imp_rows, , drop = FALSE]
      
      # Print for debugging
      cat("Variable importance for", scientific_name_i, ":\n")
      print(variable_importance_filtered)
      
      # Save as CSV with species name
      variable_importance_path <- file.path(variable_importance_dir, paste0("variable_importance_", scientific_name_i, ".csv"))
      write.csv(variable_importance_filtered, file = variable_importance_path, row.names = TRUE)
      
      cat("Variable importance saved for", scientific_name_i, "\n")
      
    } else {
      cat("No model found for", scientific_name_i, "â€” skipping variable importance export.\n")
    }
    
    
    # Predict habitat suitability for the test data
    species_i_px[[k]] <- predict(environmental_var_stack_i, 
                                 species_i_maxent_models[[k]], 
                                 ext = ext, 
                                 na.rm = TRUE,
                                 progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot( species_i_px[[k]], main = paste("Final Predicted climatic Habitat Suitability for Species", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir <- "F:/Uillinois_data/analysis/habitat_suitability/continuous_surface_predictions_reptiles/"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir)) {
      dir.create(output_dir, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_i_px)) {
      if (!is.null(species_i_px[[k]])) {
        # Define the file path for each fold
        file_path <- paste0(output_dir, "habitat_suitability_species_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_i_px[[k]], filename = file_path, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    # Evualuate model
    
    species_predictions_avg <- list()
    species_i_eval <- list()  # Initialize list to store evaluation results
    species_i_eval_summary <- data.frame(
      fpr = numeric(),
      tpr = numeric(),
      mean_tpr = numeric(),
      sd_tpr = numeric(),
      se_tpr = numeric(),
      fold = integer()
    )
    
    # Initialize a vector to store AUC values
    auc_values <- numeric()
    
    
    if(k %in% species_i_foldvector){
      
      # Save evaluation for each fold
      species_i_eval[[k]] <- evaluate(p = species_i_presbackg_sf[testSet,] %>%
                                        st_drop_geometry(.) %>%
                                        filter(p == 1) %>%
                                        dplyr::select(-p, -fold),
                                      # p = presence, a = absence
                                      a = species_i_presbackg_sf[testSet,] %>%
                                        st_drop_geometry(.) %>%
                                        filter(p == 0) %>%
                                        dplyr::select(-p,-fold), 
                                      # model = maxent model
                                      model = species_i_maxent_models[[k]],
                                      # x = environmental variable raster stack
                                      x = environmental_var_stack_i)
      
      # Ensure the evaluation object is valid before proceeding
      if (!is.null(species_i_eval[[k]])) {
        
        # Extract FPR, TPR from model evaluation
        eval_df <- data.frame(
          fpr = species_i_eval[[k]]@FPR,
          tpr = species_i_eval[[k]]@TPR,  # Ensure TPR is included
          mean_tpr = mean(species_i_eval[[k]]@TPR, na.rm = TRUE),  # Compute mean TPR
          sd_tpr = sd(species_i_eval[[k]]@TPR, na.rm = TRUE),      # Compute SD of TPR
          se_tpr = sd(species_i_eval[[k]]@TPR, na.rm = TRUE) / sqrt(length(species_i_eval[[k]]@TPR)),  # Compute SE of TPR
          fold = k
        )
        
        # Step 1: Remove any existing NA rows in species_i_eval_summary
        species_i_eval_summary <- species_i_eval_summary %>%
          filter(!is.na(tpr))
        
        # Step 2: Ensure column names match
        eval_df <- eval_df %>%
          dplyr::select(all_of(colnames(species_i_eval_summary)))  # Keep column order consistent
        
        # Step 3: Append without introducing new NA values
        species_i_eval_summary <- bind_rows(species_i_eval_summary, eval_df)
        
        # Extract AUC value for the current fold and append it to the auc_values vector
        auc_values <- c(auc_values, species_i_eval[[k]]@auc)
        
        # Print number of test observations
        num_test_obs <- species_i_presbackg_sf[testSet, ] %>%
          st_drop_geometry() %>%
          filter(p == 1) %>%
          dplyr::select(-p, -fold) %>%
          nrow()
        
        print(paste("Number of test observations in fold", k, "is", num_test_obs))
        
      } else {
        cat(" Evaluation object is NULL for fold", k, "- Skipping.\n")
      }
    }
    
    
    # Calculate the average AUC for all folds (if auc_values contains any valid values)
    if (length(auc_values) > 0) {
      avg_auc <- mean(auc_values, na.rm = TRUE)
      cat("Average AUC across all folds for", scientific_name_i, ":", avg_auc, "\n")
      
      # Update the mean_auc column in modelPerformanceAllSpecies using the species name
      row_index <- which(modelPerformanceAllSpecies$scientific_name == scientific_name_i)
      
      if (length(row_index) == 1) {
        modelPerformanceAllSpecies$mean_auc[row_index] <- avg_auc
        cat("Average AUC saved for", scientific_name_i, "\n")
      } else {
        cat("Warning: Could not uniquely identify row for species", scientific_name_i, "\n")
      }
    } else {
      cat("No valid AUC values found for species", scientific_name_i, "\n")
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices <- which(!sapply(species_i_px, is.null))
    species_i_px_valid <- species_i_px[valid_indices]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid <- rep(auc_weights_valid, length(valid_indices))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_i_px_stack <- rast(species_i_px_valid)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_i_px_stack) == 1) {
      species_i_px_avg <- species_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_i_px_avg <- app(species_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_i_px_avg, main = paste("Average Habitat Suitability -", scientific_name_i))
    
    
    #species_predictions_avg <- list()
    species_predictions_avg[[scientific_name_i]] <- species_i_px_avg
    names(species_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir1 <- "F:/Uillinois_data/analysis/habitat_suitability/continuous_surface_predictions_reptiles/average/"
    avg_suitability_path <- file.path(output_dir1, paste0("weighted_avg_habitat_suitability_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_i_px_avg, filename = avg_suitability_path, overwrite = TRUE)
      cat("Saved weighted average habitat suitability surface for", scientific_name_i, "\n")
      
      # Store in named list
      species_predictions_avg[[scientific_name_i]] <- species_i_px_avg
      
    } else {
      cat("species_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # --------------Obtaining optimal threshold---------------------------
    
    # ---------- Step 1: Extract thresholds (spec_sens) from each fold safely ----------
    fold_thresholds <- sapply(species_i_eval, function(eval_obj) {
      tryCatch({
        if (!is.null(eval_obj)) {
          dismo::threshold(eval_obj, 'spec_sens')
        } else {
          NA
        }
      }, error = function(e) NA)
    })
    
    # ---------- Step 2: Calculate valid weights ----------
    auc_weights <- (AUCs_i - 0.5)^2
    auc_weights[is.na(auc_weights)] <- 0  # zero out missing AUCs
    
    valid_folds <- which(!is.na(fold_thresholds) & auc_weights > 0)
    cat("Folds contributing to threshold calculation for", scientific_name_i, ":", paste(valid_folds, collapse = ", "), "\n")
    
    valid_thresholds <- fold_thresholds[valid_folds]
    valid_weights <- auc_weights[valid_folds]
    
    # ---------- Step 3: Compute the final threshold ----------
    if (length(valid_thresholds) > 0 && sum(valid_weights, na.rm = TRUE) > 0) {
      species_i_threshold <- weighted.mean(valid_thresholds, w = valid_weights, na.rm = TRUE)
    } else if (length(valid_thresholds) > 0) {
      species_i_threshold <- mean(valid_thresholds, na.rm = TRUE)
      cat("All weights were zero â€” used unweighted mean instead.\n")
    } else {
      species_i_threshold <- NA
      cat("No valid thresholds found â€” returning NA.\n")
    }
    
    cat("Final average threshold (spec_sens) for", scientific_name_i, ":", species_i_threshold, "\n")
    
    # ---------- Step 4: Save threshold to performance table ----------
    modelPerformanceAllSpecies$mean_threshold[modelPerformanceAllSpecies$scientific_name == scientific_name_i] <- species_i_threshold
    
    # Define file paths
    species_dir <- file.path("F:/Uillinois_data/analysis/habitat_suitability", gsub(" ", "_", scientific_name_i))
    dir.create(file.path(species_dir, "binary_reptiles"), showWarnings = FALSE, recursive = TRUE)
    
    write.csv(modelPerformanceAllSpecies,
              file = file.path(species_dir, paste0(scientific_name_i, "_performance.csv")),
              row.names = FALSE)
    cat("Model performance table saved as CSV for", scientific_name_i, "\n")
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary <- species_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary, main = paste("Binary Suitability for", scientific_name_i))
      
      binary_path <- file.path(species_dir, "binary_reptiles", paste0(scientific_name_i, "_mean_pixel_binary.tif"))
      writeRaster(
        species_i_binary,
        filename = binary_path,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    
    # ---------------------Conduct future projections------------------- 
    
    # Start by loading climatic variables
    
    # Access-CM2
    
    # A. ---------2011-2040-------------
    
    #------------2011-2040_ssp126--------------
    
    # load historical climate data
    DD0_2020s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_DD0.tif")
    EXT_2020s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_EXT.tif")
    PPT_at_2020s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_PPT_at.tif")
    PPT_sm_2020s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_PPT_sm.tif")
    PPT_wt_2020s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2020s_Access_ssp126 <- raster::stack( DD0_2020s_Access_ssp126, 
                                                                  EXT_2020s_Access_ssp126,
                                                                  PPT_at_2020s_Access_ssp126,
                                                                  PPT_sm_2020s_Access_ssp126,
                                                                  PPT_wt_2020s_Access_ssp126)
    environmental_var_stack_2020s_Access_ssp126
    
    plot(environmental_var_stack_2020s_Access_ssp126)
    
    
    names(environmental_var_stack_2020s_Access_ssp126) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2020s_Access_ssp126 <- terra::rast(environmental_var_stack_2020s_Access_ssp126)
    
    species_2020s_Access_ssp126_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2020s_Access_ssp126_i_px[[k]] <- predict(environmental_var_stack_2020s_Access_ssp126, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2020s_Access_ssp126_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2020 Access ssp126", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir2 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2020s/ssp126"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir2)) {
      dir.create(output_dir2, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2020s_Access_ssp126_i_px)) {
      if (!is.null(species_2020s_Access_ssp126_i_px[[k]])) {
        # Define the file path for each fold
        file_path2 <- paste0(output_dir2, "habitat_suitability_species_2020s_Access_ssp126_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2020s_Access_ssp126_i_px[[k]], filename = file_path2, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path2, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices1 <- which(!sapply(species_2020s_Access_ssp126_i_px, is.null))
    species_i_px_valid1 <- species_2020s_Access_ssp126_i_px[valid_indices1]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid1 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid1 <- rep(auc_weights_valid1, length(valid_indices1))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2020s_Access_ssp126_i_px_stack <- rast(species_i_px_valid1)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2020s_Access_ssp126_i_px_stack) == 1) {
      species_2020s_Access_ssp126_i_px_avg <- species_2020s_Access_ssp126_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2020s_Access_ssp126_i_px_avg <- app(species_2020s_Access_ssp126_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid1, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2020s_Access_ssp126_i_px_avg, main = paste("Average Habitat Suitability 2020s Access ssp126", scientific_name_i))
    
    
    species_2020s_Access_ssp126_predictions_avg <- list()
    species_2020s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp126_i_px_avg
    names(species_2020s_Access_ssp126_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir3 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2020s/ssp126/average/"
    avg_suitability_path3 <- file.path(output_dir3, paste0("weighted_avg_habitat_suitability_2020s_Access_ssp126_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2020s_Access_ssp126_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2020s_Access_ssp126_i_px_avg, filename = avg_suitability_path3, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2020s Access ssp126 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2020s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp126_i_px_avg
      
    } else {
      cat("species_2020s_Access_ssp126_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2020s_Access_ssp126 <- species_2020s_Access_ssp126_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2020s_Access_ssp126, main = paste("Binary Suitability 2020s Access ssp126 for", scientific_name_i))
      
      species_dir1 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2020s/ssp126", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir1, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary1 <- file.path(species_dir1, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2020s_Access_ssp126.tif"))
      writeRaster(
        species_i_binary_2020s_Access_ssp126,
        filename = binary1,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    
    # ---------2021-2040-ssp245-------------
    
    # load historical climate data
    DD0_2020s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_DD0.tif")
    EXT_2020s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_EXT.tif")
    PPT_at_2020s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_PPT_at.tif")
    PPT_sm_2020s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_PPT_sm.tif")
    PPT_wt_2020s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2020s_Access_ssp245 <- raster::stack( DD0_2020s_Access_ssp245, 
                                                                  EXT_2020s_Access_ssp245,
                                                                  PPT_at_2020s_Access_ssp245,
                                                                  PPT_sm_2020s_Access_ssp245,
                                                                  PPT_wt_2020s_Access_ssp245)
    environmental_var_stack_2020s_Access_ssp245
    
    plot(environmental_var_stack_2020s_Access_ssp245)
    
    
    names(environmental_var_stack_2020s_Access_ssp245) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2020s_Access_ssp245 <- terra::rast(environmental_var_stack_2020s_Access_ssp245)
    
    species_2020s_Access_ssp245_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2020s_Access_ssp245_i_px[[k]] <- predict(environmental_var_stack_2020s_Access_ssp245, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2020s_Access_ssp245_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2030 Access ssp245", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir22 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2020s/ssp245"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir22)) {
      dir.create(output_dir22, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2020s_Access_ssp245_i_px)) {
      if (!is.null(species_2020s_Access_ssp245_i_px[[k]])) {
        # Define the file path for each fold
        file_path22 <- paste0(output_dir22, "habitat_suitability_species_2020s_Access_ssp245_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2020s_Access_ssp245_i_px[[k]], filename = file_path22, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path22, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2020s_ssp245 <- which(!sapply(species_2020s_Access_ssp245_i_px, is.null))
    species_i_px_valid_2020s_ssp245 <- species_2020s_Access_ssp245_i_px[valid_indices_2020s_ssp245]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid2 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid2 <- rep(auc_weights_valid2, length(valid_indices_2020s_ssp245))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2020s_Access_ssp245_i_px_stack <- rast(species_i_px_valid_2020s_ssp245)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2020s_Access_ssp245_i_px_stack) == 1) {
      species_2020s_Access_ssp245_i_px_avg <- species_2020s_Access_ssp245_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2020s_Access_ssp245_i_px_avg <- app(species_2020s_Access_ssp245_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid2, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2020s_Access_ssp245_i_px_avg, main = paste("Average Habitat Suitability 2020s Access ssp245", scientific_name_i))
    
    
    species_2020s_Access_ssp245_predictions_avg <- list()
    species_2020s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp245_i_px_avg
    names(species_2020s_Access_ssp245_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir33 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2020s/ssp245/average/"
    avg_suitability_path33 <- file.path(output_dir33, paste0("weighted_avg_habitat_suitability_2020s_Access_ssp245_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2020s_Access_ssp245_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2020s_Access_ssp245_i_px_avg, filename = avg_suitability_path33, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2020s Access ssp245 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2020s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp245_i_px_avg
      
    } else {
      cat("species_2020s_Access_ssp245_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2020s_Access_ssp245 <- species_2020s_Access_ssp245_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2020s_Access_ssp245, main = paste("Binary Suitability 2020s Access ssp245 for", scientific_name_i))
      
      species_dir2 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2020s/ssp245/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir2, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path33 <- file.path(species_dir2, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2020s_Access_ssp245.tif"))
      writeRaster(
        species_i_binary_2020s_Access_ssp245,
        filename = binary_path33,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    # ---------2021-2040-ssp585-------------
    
    # load historical climate data
    DD0_2020s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_DD0.tif")
    EXT_2020s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_EXT.tif")
    PPT_at_2020s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_PPT_at.tif")
    PPT_sm_2020s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_PPT_sm.tif")
    PPT_wt_2020s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2020s_Access_ssp585 <- raster::stack( DD0_2020s_Access_ssp585, 
                                                                  EXT_2020s_Access_ssp585,
                                                                  PPT_at_2020s_Access_ssp585,
                                                                  PPT_sm_2020s_Access_ssp585,
                                                                  PPT_wt_2020s_Access_ssp585)
    environmental_var_stack_2020s_Access_ssp585
    
    plot(environmental_var_stack_2020s_Access_ssp585)
    
    
    names(environmental_var_stack_2020s_Access_ssp585) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2020s_Access_ssp585 <- terra::rast(environmental_var_stack_2020s_Access_ssp585)
    
    species_2020s_Access_ssp585_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2020s_Access_ssp585_i_px[[k]] <- predict(environmental_var_stack_2020s_Access_ssp585, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2020s_Access_ssp585_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2020 Access ssp585", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir222 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2020s/ssp585"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir222)) {
      dir.create(output_dir222, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2020s_Access_ssp585_i_px)) {
      if (!is.null(species_2020s_Access_ssp585_i_px[[k]])) {
        # Define the file path for each fold
        file_path222 <- paste0(output_dir222, "habitat_suitability_species_2020s_Access_ssp585_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2020s_Access_ssp585_i_px[[k]], filename = file_path222, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path222, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2020s_ssp585 <- which(!sapply(species_2020s_Access_ssp585_i_px, is.null))
    species_i_px_valid_2020s_ssp585 <- species_2020s_Access_ssp585_i_px[valid_indices_2020s_ssp585]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid3 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid3 <- rep(auc_weights_valid3, length(valid_indices_2020s_ssp585))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2020s_Access_ssp585_i_px_stack <- rast(species_i_px_valid_2020s_ssp585)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2020s_Access_ssp585_i_px_stack) == 1) {
      species_2020s_Access_ssp585_i_px_avg <- species_2020s_Access_ssp585_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2020s_Access_ssp585_i_px_avg <- app(species_2020s_Access_ssp585_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid3, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2020s_Access_ssp585_i_px_avg, main = paste("Average Habitat Suitability 2020s Access ssp585", scientific_name_i))
    
    
    species_2020s_Access_ssp585_predictions_avg <- list()
    species_2020s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp585_i_px_avg
    names(species_2020s_Access_ssp585_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir333 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2020s/ssp585/average/"
    avg_suitability_path333 <- file.path(output_dir333, paste0("weighted_avg_habitat_suitability_2020s_Access_ssp585_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2020s_Access_ssp585_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2020s_Access_ssp585_i_px_avg, filename = avg_suitability_path333, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2020s Access ssp585 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2020s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp585_i_px_avg
      
    } else {
      cat("species_2020s_Access_ssp585_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2020s_Access_ssp585 <- species_2020s_Access_ssp585_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2020s_Access_ssp585, main = paste("Binary Suitability 2030s Access ssp585 for", scientific_name_i))
      
      species_dir3 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2020s/ssp585/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir3, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path333 <- file.path(species_dir3, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2020s_Access_ssp585.tif"))
      writeRaster(
        species_i_binary_2020s_Access_ssp585,
        filename = binary_path333,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    # B. ---------2041-2060-------------
    
    #------------2041-2060_ssp126--------------
    
    # load historical climate data
    DD0_2050s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_DD0.tif")
    EXT_2050s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_EXT.tif")
    PPT_at_2050s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_PPT_at.tif")
    PPT_sm_2050s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_PPT_sm.tif")
    PPT_wt_2050s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2050s_Access_ssp126 <- raster::stack( DD0_2050s_Access_ssp126, 
                                                                  EXT_2050s_Access_ssp126,
                                                                  PPT_at_2050s_Access_ssp126,
                                                                  PPT_sm_2050s_Access_ssp126,
                                                                  PPT_wt_2050s_Access_ssp126)
    environmental_var_stack_2050s_Access_ssp126
    
    plot(environmental_var_stack_2050s_Access_ssp126)
    
    
    names(environmental_var_stack_2050s_Access_ssp126) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    environmental_var_stack_2050s_Access_ssp126 <- terra::rast(environmental_var_stack_2050s_Access_ssp126)
    
    species_2050s_Access_ssp126_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2050s_Access_ssp126_i_px[[k]] <- predict(environmental_var_stack_2050s_Access_ssp126, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2050s_Access_ssp126_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2050 Access ssp126", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir4 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2050s/ssp126"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir4)) {
      dir.create(output_dir4, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2050s_Access_ssp126_i_px)) {
      if (!is.null(species_2050s_Access_ssp126_i_px[[k]])) {
        # Define the file path for each fold
        file_path4 <- paste0(output_dir4, "habitat_suitability_species_2050s_Access_ssp126_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2050s_Access_ssp126_i_px[[k]], filename = file_path4, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path4, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices4 <- which(!sapply(species_2050s_Access_ssp126_i_px, is.null))
    species_i_px_valid4 <- species_2050s_Access_ssp126_i_px[valid_indices4]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid4 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid4 <- rep(auc_weights_valid4, length(valid_indices4))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2050s_Access_ssp126_i_px_stack <- rast(species_i_px_valid4)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2050s_Access_ssp126_i_px_stack) == 1) {
      species_2050s_Access_ssp126_i_px_avg <- species_2050s_Access_ssp126_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2050s_Access_ssp126_i_px_avg <- app(species_2050s_Access_ssp126_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid4, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2050s_Access_ssp126_i_px_avg, main = paste("Average Habitat Suitability 2050s Access ssp126", scientific_name_i))
    
    
    #species_predictions_avg <- list()
    species_2050s_Access_ssp126_predictions_avg <- list()
    species_2050s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp126_i_px_avg
    names(species_2050s_Access_ssp126_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir4 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2050s/ssp126/average/"
    avg_suitability_path4 <- file.path(output_dir4, paste0("weighted_avg_habitat_suitability_2050s_Access_ssp126_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2050s_Access_ssp126_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2050s_Access_ssp126_i_px_avg, filename = avg_suitability_path4, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2050s Access ssp126 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2050s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp126_i_px_avg
      
    } else {
      cat("species_2050s_Access_ssp126_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2050s_Access_ssp126 <- species_2050s_Access_ssp126_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2050s_Access_ssp126, main = paste("Binary Suitability 2050s Access ssp126 for", scientific_name_i))
      
      species_dir31 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2050s/ssp126/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir31, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path4 <- file.path(species_dir31, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2050s_Access_ssp126.tif"))
      writeRaster(
        species_i_binary_2050s_Access_ssp126,
        filename = binary_path4,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    
    # ---------2041-2060-ssp245-------------
    
    # load historical climate data
    DD0_2050s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_DD0.tif")
    EXT_2050s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_EXT.tif")
    PPT_at_2050s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_PPT_at.tif")
    PPT_sm_2050s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_PPT_sm.tif")
    PPT_wt_2050s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2050s_Access_ssp245 <- raster::stack( DD0_2050s_Access_ssp245, 
                                                                  EXT_2050s_Access_ssp245,
                                                                  PPT_at_2050s_Access_ssp245,
                                                                  PPT_sm_2050s_Access_ssp245,
                                                                  PPT_wt_2050s_Access_ssp245)
    environmental_var_stack_2050s_Access_ssp245
    
    plot(environmental_var_stack_2050s_Access_ssp245)
    
    
    names(environmental_var_stack_2050s_Access_ssp245) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2050s_Access_ssp245 <- terra::rast(environmental_var_stack_2050s_Access_ssp245)
    
    species_2050s_Access_ssp245_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2050s_Access_ssp245_i_px[[k]] <- predict(environmental_var_stack_2050s_Access_ssp245, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2050s_Access_ssp245_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2050 Access ssp245", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir44 <- " F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2050s/ssp245"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir44)) {
      dir.create(output_dir44, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2050s_Access_ssp245_i_px)) {
      if (!is.null(species_2050s_Access_ssp245_i_px[[k]])) {
        # Define the file path for each fold
        file_path44 <- paste0(output_dir44, "habitat_suitability_species_2050s_Access_ssp245_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2050s_Access_ssp245_i_px[[k]], filename = file_path44, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path44, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2050s_ssp245 <- which(!sapply(species_2050s_Access_ssp245_i_px, is.null))
    species_i_px_valid_2050s_ssp245 <- species_2050s_Access_ssp245_i_px[valid_indices_2050s_ssp245]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid44 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid44 <- rep(auc_weights_valid44, length(valid_indices_2050s_ssp245))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2050s_Access_ssp245_i_px_stack <- rast(species_i_px_valid_2050s_ssp245)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2050s_Access_ssp245_i_px_stack) == 1) {
      species_2050s_Access_ssp245_i_px_avg <- species_2050s_Access_ssp245_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2050s_Access_ssp245_i_px_avg <- app(species_2050s_Access_ssp245_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid44, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2050s_Access_ssp245_i_px_avg, main = paste("Average Habitat Suitability 2050s Access ssp245", scientific_name_i))
    
    
    species_2050s_Access_ssp245_predictions_avg <- list()
    species_2050s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp245_i_px_avg
    names(species_2050s_Access_ssp245_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir444 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2050s/ssp245/average/"
    avg_suitability_path444 <- file.path(output_dir444, paste0("weighted_avg_habitat_suitability_2050s_Access_ssp245_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2050s_Access_ssp245_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2050s_Access_ssp245_i_px_avg, filename = avg_suitability_path444, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2050s Access ssp245 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2050s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp245_i_px_avg
      
    } else {
      cat("species_2050s_Access_ssp245_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2050s_Access_ssp245 <- species_2050s_Access_ssp245_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2050s_Access_ssp245, main = paste("Binary Suitability 2050s Access ssp245 for", scientific_name_i))
      
      species_dir4 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2050s/ssp245/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir4, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path444 <- file.path(species_dir4, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2050s_Access_ssp126.tif"))
      writeRaster(
        species_i_binary_2050s_Access_ssp245,
        filename = binary_path444,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    # ---------2041-2060-ssp585-------------
    
    # load historical climate data
    DD0_2050s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_DD0.tif")
    EXT_2050s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_EXT.tif")
    PPT_at_2050s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_PPT_at.tif")
    PPT_sm_2050s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_PPT_sm.tif")
    PPT_wt_2050s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2050s_Access_ssp585 <- raster::stack( DD0_2050s_Access_ssp585, 
                                                                  EXT_2050s_Access_ssp585,
                                                                  PPT_at_2050s_Access_ssp585,
                                                                  PPT_sm_2050s_Access_ssp585,
                                                                  PPT_wt_2050s_Access_ssp585)
    environmental_var_stack_2050s_Access_ssp585
    
    plot(environmental_var_stack_2050s_Access_ssp585)
    
    
    names(environmental_var_stack_2050s_Access_ssp585) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    environmental_var_stack_2050s_Access_ssp585 <- terra::rast(environmental_var_stack_2050s_Access_ssp585)
    
    species_2050s_Access_ssp585_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2050s_Access_ssp585_i_px[[k]] <- predict(environmental_var_stack_2050s_Access_ssp585, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2050s_Access_ssp585_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2030 Access ssp585", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir5 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2050s/ssp585"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir5)) {
      dir.create(output_dir5, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2050s_Access_ssp585_i_px)) {
      if (!is.null(species_2050s_Access_ssp585_i_px[[k]])) {
        # Define the file path for each fold
        file_path5 <- paste0(output_dir5, "habitat_suitability_species_2050s_Access_ssp585_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2050s_Access_ssp585_i_px[[k]], filename = file_path5, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path5, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2050s_ssp585 <- which(!sapply(species_2050s_Access_ssp585_i_px, is.null))
    species_i_px_valid_2050s_ssp585 <- species_2050s_Access_ssp585_i_px[valid_indices_2050s_ssp585]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid5 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid5 <- rep(auc_weights_valid5, length(valid_indices_2050s_ssp585))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2050s_Access_ssp585_i_px_stack <- rast(species_i_px_valid_2050s_ssp585)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2050s_Access_ssp585_i_px_stack) == 1) {
      species_2050s_Access_ssp585_i_px_avg <- species_2050s_Access_ssp585_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2050s_Access_ssp585_i_px_avg <- app(species_2050s_Access_ssp585_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid5, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2050s_Access_ssp585_i_px_avg, main = paste("Average Habitat Suitability 2050s Access ssp585", scientific_name_i))
    
    
    species_2050s_Access_ssp585_predictions_avg <- list()
    species_2050s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp585_i_px_avg
    names(species_2050s_Access_ssp585_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir55 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2050s/ssp585/average/"
    avg_suitability_path55 <- file.path(output_dir55, paste0("weighted_avg_habitat_suitability_2050s_Access_ssp585_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2050s_Access_ssp585_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2050s_Access_ssp585_i_px_avg, filename = avg_suitability_path55, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2050s Access ssp585 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2050s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp585_i_px_avg
      
    } else {
      cat("species_2050s_Access_ssp585_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2050s_Access_ssp585 <- species_2050s_Access_ssp585_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2050s_Access_ssp585, main = paste("Binary Suitability 2050s Access ssp585 for", scientific_name_i))
      
      species_dir5 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2050s/ssp585/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir5, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path55 <- file.path(species_dir5, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2050s_Access_ssp585.tif"))
      writeRaster(
        species_i_binary_2050s_Access_ssp585,
        filename = binary_path55,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    # C. ---------2061-2080-------------
    
    #------------2061-2080_ssp126--------------
    
    # load historical climate data
    DD0_2070s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_DD0.tif")
    EXT_2070s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_EXT.tif")
    PPT_at_2070s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_PPT_at.tif")
    PPT_sm_2070s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_PPT_sm.tif")
    PPT_wt_2070s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2070s_Access_ssp126 <- raster::stack( DD0_2070s_Access_ssp126, 
                                                                  EXT_2070s_Access_ssp126,
                                                                  PPT_at_2070s_Access_ssp126,
                                                                  PPT_sm_2070s_Access_ssp126,
                                                                  PPT_wt_2070s_Access_ssp126)
    environmental_var_stack_2070s_Access_ssp126
    
    plot(environmental_var_stack_2070s_Access_ssp126)
    
    
    names(environmental_var_stack_2070s_Access_ssp126) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    environmental_var_stack_2070s_Access_ssp126 <- terra::rast(environmental_var_stack_2070s_Access_ssp126)
    
    species_2070s_Access_ssp126_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2070s_Access_ssp126_i_px[[k]] <- predict(environmental_var_stack_2070s_Access_ssp126, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2070s_Access_ssp126_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2070 Access ssp126", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir6 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2070s/ssp126"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir6)) {
      dir.create(output_dir6, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2070s_Access_ssp126_i_px)) {
      if (!is.null(species_2070s_Access_ssp126_i_px[[k]])) {
        # Define the file path for each fold
        file_path6 <- paste0(output_dir6, "habitat_suitability_species_2070s_Access_ssp126_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2070s_Access_ssp126_i_px[[k]], filename = file_path6, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path6, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices6 <- which(!sapply(species_2070s_Access_ssp126_i_px, is.null))
    species_i_px_valid6 <- species_2070s_Access_ssp126_i_px[valid_indices6]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid6 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid6 <- rep(auc_weights_valid6, length(valid_indices6))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2070s_Access_ssp126_i_px_stack <- rast(species_i_px_valid6)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2070s_Access_ssp126_i_px_stack) == 1) {
      species_2070s_Access_ssp126_i_px_avg <- species_2070s_Access_ssp126_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2070s_Access_ssp126_i_px_avg <- app(species_2070s_Access_ssp126_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid6, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2070s_Access_ssp126_i_px_avg, main = paste("Average Habitat Suitability 2070s Access ssp126", scientific_name_i))
    
    
    species_2070s_Access_ssp126_predictions_avg <- list()
    species_2070s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp126_i_px_avg
    names(species_2070s_Access_ssp126_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir66 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2070s/ssp126/average/"
    avg_suitability_path66 <- file.path(output_dir66, paste0("weighted_avg_habitat_suitability_2070s_Access_ssp126_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2070s_Access_ssp126_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2070s_Access_ssp126_i_px_avg, filename = avg_suitability_path66, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2070s Access ssp126 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2070s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp126_i_px_avg
      
    } else {
      cat("species_2070s_Access_ssp126_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2070s_Access_ssp126 <- species_2070s_Access_ssp126_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2070s_Access_ssp126, main = paste("Binary Suitability 2070s Access ssp126 for", scientific_name_i))
      
      species_dir6 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2070s/ssp126/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir6, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path66 <- file.path(species_dir6, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2070s_Access_ssp126.tif"))
      writeRaster(
        species_i_binary_2070s_Access_ssp126,
        filename = binary_path66,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    # ---------2061-2080-ssp245-------------
    
    # load historical climate data
    DD0_2070s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_DD0.tif")
    EXT_2070s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_EXT.tif")
    PPT_at_2070s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_PPT_at.tif")
    PPT_sm_2070s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_PPT_sm.tif")
    PPT_wt_2070s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2070s_Access_ssp245 <- raster::stack( DD0_2070s_Access_ssp245, 
                                                                  EXT_2070s_Access_ssp245,
                                                                  PPT_at_2070s_Access_ssp245,
                                                                  PPT_sm_2070s_Access_ssp245,
                                                                  PPT_wt_2070s_Access_ssp245)
    environmental_var_stack_2070s_Access_ssp245
    
    plot(environmental_var_stack_2070s_Access_ssp245)
    
    
    names(environmental_var_stack_2070s_Access_ssp245) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2070s_Access_ssp245 <- terra::rast(environmental_var_stack_2070s_Access_ssp245)
    
    species_2070s_Access_ssp245_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2070s_Access_ssp245_i_px[[k]] <- predict(environmental_var_stack_2070s_Access_ssp245, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2070s_Access_ssp245_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2070 Access ssp245", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir7 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2070s/ssp245"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir7)) {
      dir.create(output_dir7, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2070s_Access_ssp245_i_px)) {
      if (!is.null(species_2070s_Access_ssp245_i_px[[k]])) {
        # Define the file path for each fold
        file_path7 <- paste0(output_dir7, "habitat_suitability_species_2070s_Access_ssp245_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2070s_Access_ssp245_i_px[[k]], filename = file_path7, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path7, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2070s_ssp245 <- which(!sapply(species_2070s_Access_ssp245_i_px, is.null))
    species_i_px_valid_2070s_ssp245 <- species_2070s_Access_ssp245_i_px[valid_indices_2070s_ssp245]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid77 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid77 <- rep(auc_weights_valid77, length(valid_indices_2070s_ssp245))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2070s_Access_ssp245_i_px_stack <- rast(species_i_px_valid_2070s_ssp245)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2070s_Access_ssp245_i_px_stack) == 1) {
      species_2070s_Access_ssp245_i_px_avg <- species_2070s_Access_ssp245_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2070s_Access_ssp245_i_px_avg <- app(species_2070s_Access_ssp245_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid77, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2070s_Access_ssp245_i_px_avg, main = paste("Average Habitat Suitability 2070s Access ssp245", scientific_name_i))
    
    
    species_2070s_Access_ssp245_predictions_avg <- list()
    species_2070s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp245_i_px_avg
    names(species_2070s_Access_ssp245_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir77 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2070s/ssp245/average/"
    avg_suitability_path77 <- file.path(output_dir77, paste0("weighted_avg_habitat_suitability_2070s_Access_ssp245_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2070s_Access_ssp245_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2070s_Access_ssp245_i_px_avg, filename = avg_suitability_path77, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2070s Access ssp245 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2070s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp245_i_px_avg
      
    } else {
      cat("species_2070s_Access_ssp245_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2070s_Access_ssp245 <- species_2070s_Access_ssp245_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2070s_Access_ssp245, main = paste("Binary Suitability 2070s Access ssp245 for", scientific_name_i))
      
      species_dir7 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2070s/ssp245/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir7, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path77 <- file.path(species_dir7, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2070s_Access_ssp245.tif"))
      writeRaster(
        species_i_binary_2070s_Access_ssp245,
        filename = binary_path77,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    # ---------2061-2080-ssp585-------------
    
    # load historical climate data
    DD0_2070s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_DD0.tif")
    EXT_2070s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_EXT.tif")
    PPT_at_2070s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_PPT_at.tif")
    PPT_sm_2070s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_PPT_sm.tif")
    PPT_wt_2070s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2070s_Access_ssp585 <- raster::stack( DD0_2070s_Access_ssp585, 
                                                                  EXT_2070s_Access_ssp585,
                                                                  PPT_at_2070s_Access_ssp585,
                                                                  PPT_sm_2070s_Access_ssp585,
                                                                  PPT_wt_2070s_Access_ssp585)
    environmental_var_stack_2070s_Access_ssp585
    
    plot(environmental_var_stack_2070s_Access_ssp585)
    
    
    names(environmental_var_stack_2070s_Access_ssp585) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2070s_Access_ssp585 <- terra::rast(environmental_var_stack_2070s_Access_ssp585)
    
    species_2070s_Access_ssp585_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2070s_Access_ssp585_i_px[[k]] <- predict(environmental_var_stack_2070s_Access_ssp585, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2070s_Access_ssp585_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2070 Access ssp585", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir8 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2070s/ssp585"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir8)) {
      dir.create(output_dir8, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2070s_Access_ssp585_i_px)) {
      if (!is.null(species_2070s_Access_ssp585_i_px[[k]])) {
        # Define the file path for each fold
        file_path8 <- paste0(output_dir8, "habitat_suitability_species_2070s_Access_ssp585_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2070s_Access_ssp585_i_px[[k]], filename = file_path8, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path8, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2070s_ssp585 <- which(!sapply(species_2070s_Access_ssp585_i_px, is.null))
    species_i_px_valid_2070s_ssp585 <- species_2070s_Access_ssp585_i_px[valid_indices_2070s_ssp585]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid8 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid8 <- rep(auc_weights_valid8, length(valid_indices_2070s_ssp585))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2070s_Access_ssp585_i_px_stack <- rast(species_i_px_valid_2070s_ssp585)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2070s_Access_ssp585_i_px_stack) == 1) {
      species_2070s_Access_ssp585_i_px_avg <- species_2070s_Access_ssp585_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2070s_Access_ssp585_i_px_avg <- app(species_2070s_Access_ssp585_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid8, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2070s_Access_ssp585_i_px_avg, main = paste("Average Habitat Suitability 2070s Access ssp585", scientific_name_i))
    
    
    species_2070s_Access_ssp585_predictions_avg <- list()
    species_2070s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp585_i_px_avg
    names(species_2070s_Access_ssp585_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir88 <- "F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2070s/ssp585/average/"
    avg_suitability_path88 <- file.path(output_dir88, paste0("weighted_avg_habitat_suitability_2070s_Access_ssp585_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2070s_Access_ssp585_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2070s_Access_ssp585_i_px_avg, filename = avg_suitability_path88, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2070s Access ssp585 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2070s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp585_i_px_avg
      
    } else {
      cat("species_2070s_Access_ssp585_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2070s_Access_ssp585 <- species_2070s_Access_ssp585_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2070s_Access_ssp585, main = paste("Binary Suitability 2070s Access ssp585 for", scientific_name_i))
      
      species_dir8 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/reptiles_future/2070s/ssp585/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir8, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path88 <- file.path(species_dir8, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2070s_Access_ssp585.tif"))
      writeRaster(
        species_i_binary_2070s_Access_ssp585,
        filename = binary_path88,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
  }}






#----------------Repeat for mammals----------------------------

# load historical climate data
DD0 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_DD0.tif")
DD0
EXT <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_EXT.tif")
EXT
PPT_at <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_PPT_at.tif")
PPT_sm <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_PPT_sm.tif")
PPT_wt <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/historical/masked_PPT_wt.tif")


# Stack all environmental rasters (raster stack)
environmental_var_stack <- raster::stack(DD0, EXT, PPT_at, PPT_sm, PPT_wt)
environmental_var_stack

plot(environmental_var_stack)


names(environmental_var_stack) <- c(
  "DD0",
  "EXT",
  "PPT_at",
  "PPT_sm",
  "PPT_wt"
)


na_check <- sapply(1:nlayers(environmental_var_stack), function(i) {
  sum(is.na(values(environmental_var_stack[[i]])))
})
names(na_check) <- names(environmental_var_stack)
na_check

plot(is.na(environmental_var_stack[[1]]), main = "NA areas in BIO4")


# Read study area 
shapefile_path <- "F:/Uillinois_data/study_area/study_area_projected.shp"
studyarea <- st_read(shapefile_path)  # Path to your study area shapefile

study_area <- studyarea %>%
  # Transform the CRS of the ppr_region to match that of environmental variables(environmental_var_stack)
  st_transform(crs = crs(environmental_var_stack)) %>%
  # Remove the Z dimension, if present
  st_zm() %>%
  # Convert sf (simple feature) to sp (spatial) object
  as_Spatial()

plot(DD0)
plot(study_area, add = TRUE, border = "red", lwd = 2)


##3. Second step is to load species list and observations 

# I start by loading the csv file that contains the list of all species for the prairie region, filter and modify the data, and adds columns for model performance and environmental variables
modelPerformanceAllSpecies <- read.csv("F:/Uillinois_data/analysis/habitat_suitability/MWCASCBiodiversityAllSpecies_mammal.csv") %>%
  filter(n_MWCASC > 20) %>% # this code filters and keep rows where the n_SECanada column has  20 observation records or more. 20 records is the minimum threshold required for fitting models for the SE Canada region
  dplyr::select(-X) %>%
  # the below code adds to two columns with variables mean_auc and mean_threshold, initialized with a NA value in inorder to store future model performance values
  mutate(mean_auc = NA,
         mean_threshold = NA) %>%
  # add blank columns for mean species values of each environmental variable, and filling them with NA values
  cbind(., t(rep(NA,length(names(environmental_var_stack)))))

dim(modelPerformanceAllSpecies)  # checks the number of rows and columns in the species list
head(modelPerformanceAllSpecies)# checks some few rows to see how the data looks like with the columns added
View(modelPerformanceAllSpecies)

#add environmental variable names to data frame
# the code below retrieves and adds new columns to the modelPerformanceAllSpecies file, with names of each environmental variable in the raster stack, starting from the 8th column to the last column (ncol(modelPerformanceAllSpecies))
names(modelPerformanceAllSpecies)[8:ncol(modelPerformanceAllSpecies)] <- names(environmental_var_stack)

#Now reprint the modelPerformanceAllSpecies data to check if the environmental variables have been successfully added 
head(modelPerformanceAllSpecies)
View(modelPerformanceAllSpecies)

# Load species observation data 
mammal_observations <- read.csv("F:/Uillinois_data/analysis/habitat_suitability/mammal_observations_cleaned.csv")

# Combine all observations
species_observations <- rbind(mammal_observations) 
head(species_observations)

# Species observations are still in dataframe format, hence, a need to convert the data frame to an sf object
species_observations_sf <- st_as_sf(
  species_observations,
  coords = c("longitude", "latitude"),
  crs = 4326,  # WGS84 coordinate reference system
  remove = FALSE  # Keeps the original longitude and latitude columns
)

# Check the structure
print(species_observations_sf)

# Reproject the sf object to the CRS of bio4 (e.g., a raster layer)
species_observations_transformed <- st_transform(species_observations_sf, crs = st_crs(environmental_var_stack))

# Remove rows where "species" column is NA
species_observations_cleaned <- species_observations_transformed[!is.na(species_observations_transformed$species), ]

# Check the result
head(species_observations_cleaned)
# Plot observation points and visualize on climate maps
plot(environmental_var_stack[[1]], main = "Reprojected & Masked Bio9 Layer")
# Add the species points
plot(species_observations_cleaned, 
     add = TRUE, 
     col = "red", 
     pch = 16)


# Step 2: Remove Z/M dimensions if present (if needed for conversion to Spatial)
species_observations_reproj <- st_zm(species_observations_cleaned)

# Get the extent of environmental_var_stack as an sf polygon
env_extent <- as(extent(environmental_var_stack), "SpatialPolygons")
crs(env_extent) <- crs(environmental_var_stack)
env_extent_sf <- st_as_sf(env_extent)

# Clip points that fall within extent
species_observations_clipped <- st_intersection(species_observations_reproj, env_extent_sf)

# Plot
plot(environmental_var_stack[[1]], main = "Clipped Species Observations on Bio4")
plot(st_geometry(species_observations_clipped), 
     add = TRUE, 
     col = "red", 
     pch = 16)


### Use loop to create raster for each taxonomic group.
# In this section, I will start by defining a group vector, by assigning the taxonomic groups that will be iterated in a loop
# Print unique names in the "group" column
unique_groups <- unique(species_observations_clipped$group)# get group names from observation data
print(unique_groups)

group_vector <- c("mammals")

# The second stage is to Store target group Sampling raster in a list (named by taxon)
# Here, I will first create an empty list to store raster objects, that will be created as kernel density estimates for each taxonomic group
observations_kde_list <- list()

names(environmental_var_stack)


# Next, is to define resolution and extent based on environmental_mask. This will ensure that all raster layers that will be generated, will follow thesame resolution and spatial extents as those of the stacked raster layers created at the early stage (e.g., forest
# first, create an environmental mask for one of the stacked raster layer (here i use forest), which will be used in setting the desired resolution and extent for all other raster objects as i move forward
environmental_mask <- terra::rast(environmental_var_stack$DD0)
# second, I create a target resolution to be used for all raster layers as I proceed, by extracting the resolution of the masked raster layer (forest), using the terra package
target_resolution <- terra::res(environmental_mask)
# third, I also create a target extent that will be used for all raster layers to be developed, by extracting the extent of the masked raster
target_extent <- terra::ext(environmental_mask)

environmental_mask
plot(environmental_mask)
target_resolution
target_extent

for(g in group_vector){ # this function defines a loop over each element in the group_vector defined above (birds, mammals, amphibians and reptiles), where data specific to each group, g, will be processed independently in each iteration in the loop
  # after defining the loop function, the next thing is to ensure that each species observation is filtered to include only records for the group, g, with these records converted to a spatial format for further processing
  group_g_observations <- species_observations_clipped %>%
    filter(group == g) %>%
    slice_sample(n = 100000)  # for each group with filtered records, I randomly sample about 100,000 observations for producing KDE. 100,000 observations seem to be a manageable threshold record for each group in every KDE operation
  
  # Check if there are any observations to process
  if (nrow(group_g_observations) == 0) {
    message("No observations for group: ", g)
    next  # Skip to the next group if no data
  }
  summary(group_g_observations)
  
  # next, for each group observation g, convert the coordinates to simple feature feature (sf) objects using the sf package, so it becomes compatible with spatial feature functions in R
  group_g_observations_sf <- st_as_sf(group_g_observations, coords = c("longitude", "latitude"), crs = 4326) # here, I have converted the coordinates to EPSG:4326, the standard World Geodetic coordinate system 
  
  # the next thing is to project the group_g_observations_sf data to match that of the stacked environmental layers
  group_g_observations_sf <- st_transform(group_g_observations_sf, st_crs(environmental_var_stack))
  
  # I will now calculate KDE (kernel density estimates) for each group observation g, by masking the calculations (raster data) to the target resolution defined in the earlier face of the codes, using the resolution of one of the stacked predictors (forest). I am using the spatialEco package to do this
  kde_result <- spatialEco::sp.kde(
    x = group_g_observations_sf,
    res = target_resolution,   # Set KDE resolution to match environmental_mask
    standardize = TRUE #normalizes the density values to make them comparable across groups.
  )
  # Check the class of the KDE result and resample if needed
  # here, there is a need to verify is the KDE results produced are SpatRaster objects, considering that the package used now is the terra package, which has replaced the previos Rgeos package that has depreciated
  # the code therefore ensures that, If kde_result is not a SpatRaster object, then, the stop() function is executed to halt the operation and display the message "KDE result is not a SpatRaster." This ensures that only valid SpatRaster objects are processed in the next steps.
  if (!inherits(kde_result, "SpatRaster")) {
    stop("KDE result is not a SpatRaster.")
  }
  
  # After calculating the KDE for each species observation, g, there is a need ensure that the results fall within the geographic boundaries of the target extent (forest), define in the earlier stage of this script
  kde_result <- terra::crop(kde_result, environmental_mask)  # Crop to target extent using the crop function of the terra package
  kde_result <- terra::resample(kde_result, environmental_mask, method = "bilinear")  # although the target resolution has been specified in the KDE calculations, it is always a good approach to resample to target resolution again after coping the target extent. Also, the bilinear interpolation in the raster resampling, ensures that new pixel values are calculated based on the weighted average of surrounding pixels, yielding a smoother result
  
  # To ensure that there is no mismatch in spatial extents and resolutions between the calculated KDEs and masked or stacked environmental layers, there is a need to mask the KDE result with the stacked or masked environmental layer (forest)
  observations_kde_list[[g]] <- terra::mask(kde_result, environmental_mask)
}


# Plot KDE results for each group
par(mfrow = c(1, 1))  # Arrange plots in a 2x2 grid

for (g in names(observations_kde_list)) {
  plot(observations_kde_list[[g]], main = paste("KDE for", g))
}


# Set species common name: here, I extract the common name of each species in each row i (within the modelPerformanceAllSpecies csv file), and store it in a new variable called scientific_name_i, for easy reference in the loop iterations
for (i in 1:nrow(modelPerformanceAllSpecies)) {
  # Extract key species attributes
  group_i <- modelPerformanceAllSpecies$group[i]  
  genus_i <- modelPerformanceAllSpecies$genus[i]
  species_i <- modelPerformanceAllSpecies$species[i]
  scientific_name_i <- modelPerformanceAllSpecies$scientific_name[i]
  common_name_i <- modelPerformanceAllSpecies$scientific_name[i]
  
  message("\nProcessing species: ", scientific_name_i, " (", genus_i, " ", species_i, ") in group: ", group_i)
  
  # Ensure KDE raster exists for this group
  if (!group_i %in% names(observations_kde_list)) {
    message("No KDE raster available for group: ", group_i, " - Skipping species: ", scientific_name_i)
    next
  }
  observations_kde_group_i <- observations_kde_list[[group_i]]
  
  # Filter species observations
  species_i_sp <- species_observations_clipped %>%
    filter(scientific_name == scientific_name_i) %>%
    slice_sample(n = 1, by = square_id)  # Avoids spatial autocorrelation issues
  
  if (nrow(species_i_sp) == 0) {
    message("No valid occurrences found for species: ", scientific_name_i, " - Skipping.")
    next
  }
  
  # Convert species occurrence data to spatial format
  species_i_sp <- st_as_sf(species_i_sp, coords = c("longitude", "latitude"), crs = 4326)
  
  # Ensure study_area is an sf object and matches CRS
  study_area <- st_as_sf(study_area)
  
  if (st_crs(species_i_sp) != st_crs(study_area)) {
    message("Transforming CRS of study area to match species observations.")
    study_area <- st_transform(study_area, st_crs(species_i_sp))
  }
  
  # Print key elements for debugging (optional)
  print(observations_kde_group_i)
  
  # Intersect species points with the study area
  species_i_intersects_SE <- st_intersects(species_i_sp, study_area, sparse = FALSE)
  
  # Filter species points by intersection (keep only points inside the study area)
  species_i_sp <- species_i_sp[which(rowSums(species_i_intersects_SE) > 0), ]
  
  # Check if there are any remaining points after filtering
  if (nrow(species_i_sp) == 0) {
    message("No valid intersection found for species: ", scientific_name_i, " - Skipping.")
    modelPerformanceAllSpecies$n_MWCASC[i] <- 0  # Assign zero if no observations remain
    next
  }
  
  # Transform the CRS of the filtered points to match the environmental variable stack
  species_i_sp <- st_transform(species_i_sp, st_crs(environmental_var_stack))
  
  # Extract unique observation points (latitude and longitude), removing duplicate coordinates
  obs_species_i <- unique(st_coordinates(species_i_sp))
  
  # Convert the matrix of coordinates into a data frame
  obs_species_i <- data.frame(longitude = obs_species_i[, 1],
                              latitude = obs_species_i[, 2])
  
  # Check the first few records (optional for debugging)
  head(obs_species_i)
  
  # Save sample size: store the count of unique observation points in modelPerformanceAllSpecies
  modelPerformanceAllSpecies$n_MWCASC[i] <- nrow(obs_species_i)
  
  # Optional: Print progress update
  message("Processed ", nrow(obs_species_i), " unique occurrences for species: ", common_name_i)
  
  # Define output folder and create it if it doesn't exist
  output_dir_range <- "F:/Uillinois_data/analysis/habitat_suitability/species_range_mammals"
  dir.create(output_dir_range, recursive = TRUE, showWarnings = FALSE)
  
  # Only model species with >= 20 observations
  if(modelPerformanceAllSpecies$n_MWCASC[i] >= 20){# here, i first of all check and select the number of unique observations filtered for the prairie region (n_prairie) in each row of the modelPerformanceAllSpecies data, with records  >= 20; 20 is the minimum threshold)
    # I now assign the obs_species_i data frame (which contains the unique coordinates in each grid id) into a new variable "species_i_ppr_sp", assign lon and lat coordinates to make it a spatial object, and finally project the variable to a similar CRS with the stacked environmental variables
    species_i_sp <- obs_species_i
    coordinates(species_i_sp) <- c("longitude", "latitude")
    species_i_sp@proj4string <- raster::crs(environmental_var_stack)
    
    # Generate a 50 km buffer around each observation point
    species_i_buffers <- spTransform(species_i_sp, CRS = raster::crs(environmental_var_stack)) %>%
      raster::buffer(width = 50000)  # 5 km buffer around each observation
    
    # Convert the buffer to an sf object for easier handling
    species_i_buffers_sf <- st_as_sf(species_i_buffers)
    
    # Dissolve and merge all buffers
    species_i_buffers_dissolved <- species_i_buffers_sf %>%
      st_union()  # Dissolve all buffers into a single polygon
    
    # Define species name and file path
    species_names <- modelPerformanceAllSpecies$species[i]
    shapefile_path <- file.path(output_dir_range, paste0(gsub(" ", "_", species_names), "_range.shp"))
    
    # Save the shapefile
    st_write(species_i_buffers_dissolved, shapefile_path, delete_layer = TRUE)
    
    # Plot the dissolved buffer (clipped to the study area) and the study area
    #par(mfrow = c(1, 1))  # Set up a single panel for plotting
    #plot(st_geometry(species_i_buffers_dissolved), main = "Clipped Dissolved 5 km Buffer for Fowler's Toad Observations", col = "lightblue")
    #plot(st_geometry(clipped_study_area_proj), add = TRUE, border = "black")  # Overlay study area
    
    
    ggplot() +
      geom_sf(data = study_area, fill = "gray95", color = "black") +
      geom_sf(data = st_as_sf(species_i_buffers_dissolved), color = "darkgreen", size = 2, alpha = 0.7) +
      theme_minimal() +
      labs(title = "Species Observations",
           subtitle = "Species Observations within the Study Area",
           caption = "Species observation points have been transformed to match CRS")
    
    
    # Now Calculate species range size
    species_i_rangesize <- species_i_buffers_dissolved %>% 
      st_intersection(study_area) %>%  # Intersects the species buffer with the clipped study area to remove parts outside
      st_area() %>%  # Calculates the total area of the intersected buffers
      as.numeric() %>%  # Converts the calculated area to numeric for ease of further analysis
      sum()  # Sums up areas of multiple polygons to get the total range size
    species_i_rangesize
    
    # Estimate study area size
    study_area_size <- st_area(study_area) %>% as.numeric()
    study_area_size 
    
    # Ensure the buffer has the same CRS as the environmental variable stack
    species_i_buffers_dissolved <- st_transform(species_i_buffers_dissolved, crs = st_crs(environmental_var_stack))
    
    # Convert the dissolved buffer to an sp object
    species_i_buffers_dissolved_sp <- as(species_i_buffers_dissolved, "Spatial")
    
    # Now apply the crop and mask functions
    if(species_i_rangesize >= 0.9 * 2.018284e+12){ # Use full study area if range size is >= 90% of study area
      environmental_var_stack_i <- environmental_var_stack  # Use the entire study area
    } else {
      environmental_var_stack_i <- environmental_var_stack %>%
        raster::crop(., species_i_buffers_dissolved_sp) %>%  # Crop environmental data to species' range
        raster::mask(., species_i_buffers_dissolved_sp)  # Mask environmental data to species' range
    }
    
    # Plot to visualize the environmental variable stack and buffer
    plot(environmental_var_stack_i$DD0)
    plot(species_i_buffers_dissolved, add = TRUE, lty = 5)  # Overlay species buffer on top of the environmental data
    
    # Use the full study area, regardless of the species' range size
    environmental_var_stack_i <- environmental_var_stack  # Use the entire study area
    
    # Convert species_i_sp to an sf object if it is a SpatialPointsDataFrame
    species_i_sf <- st_as_sf(species_i_sp)
    
    # Next, is to extract values of environmental_var_stack_i for all obs_species_i
    modelPerformanceAllSpecies[i,8:ncol(modelPerformanceAllSpecies)] <- raster::extract(environmental_var_stack_i,
                                                                                        species_i_sf) %>%
      # first, this code ensures that the raster values of each environmental variable (within the stacked raster) is extracted for every given location of a species, within the species observation variable, "species_i_ppr_sp".
      # through this approach, a data structure is created for each observation point, where each column represents each environmental variable, and each row represents each observation 
      as_tibble(.) %>% # here, the data structure is converted to a tibble, a modern data frame structure in R that facilitates subsequent operations
      summarize_all(., mean, na.rm = TRUE) # this operation ensures that the mean of each environmental variable is calculated across observations for the said variable, ignoring all NA values
    # In the definition,modelPerformanceAllSpecies[i, 8:ncol(modelPerformanceAllSpecies)] <- ..., the calculated means areassigned to columns 8 onward for each row, i, of the modelPerformanceAllSpecies data frame. The results of these columns are required for evaluating model performance or habitat suitability for species in subsequent analysis
    
    modelPerformanceAllSpecies[i,8:ncol(modelPerformanceAllSpecies)]
    
    # Because the environmental_var_stack_i variable created above is still working with the raster package, there is need to the data to a SpatRaster in order to avoid model fitting and evaluation errors
    environmental_var_stack_i <- terra::rast(environmental_var_stack_i)
    # after converting to a SpatRaster, we need to ensure that our species KDE calculated in th earlier stage of this analysis matches the extent and resolution of our newly created environmental_var_stack_ic SpatRaster object
    # It should be noted that KDE raster captures observation biases
    observationbias_species_i <- observations_kde_group_i %>%
      terra::crop(environmental_var_stack_i) %>%
      terra::mask(environmental_var_stack_i)
    observationbias_species_i
    
    
    # Check if the observation bias raster has any values
    plot(observationbias_species_i)
    
    # If it's empty or not valid, skip further processing for this species
    if (all(is.na(values(observationbias_species_i)))) {
      message("Observation bias is empty for species: ", scientific_name_i, " - Skipping further analysis")
    } else {
      # Plot the observation bias for species
      plot(observationbias_species_i)
    }
  }
  
  
  # Next, is to generate background points based on species range size pixels
  # However, I will first, calculate the number of pixels in the species range, using the global() function from the terra package 
  species_i_rangepixels <- global(((observationbias_species_i[[1]] * 0) + 1), 'sum', na.rm = TRUE)[1, 1]
  # Here, the observationbias_species_i[[1]] * 0 creates a raster with the same structure as observationbias_species_i but filled with zeros
  # + 1 then turns all pixel values to 1, representing each pixel as a unit.
  #global(..., 'sum', na.rm = TRUE) then sums all these pixel values, providing the count of pixels that cover the species' range
  # the [1, 1] extracts this count from the result, storing it in species_i_rangepixels.
  species_i_rangepixels
  
  # Now, determine background points based on species range size pixels
  if(species_i_rangepixels < 100000){
    # Use 20% for small ranges i.e., assign backg_n as 20% of species_i_rangepixels
    backg_n <- round(species_i_rangepixels*0.2, 0)
  }else if(species_i_rangepixels >= 100000 & species_i_rangepixels < 250000){
    # Use 10% for medium ranges i.e., assign backg_n as 10% of species_i_rangepixels
    backg_n <- round(species_i_rangepixels*0.1, 0)
  }else if(species_i_rangepixels >= 250000){
    # Use 5% for big ranges
    backg_n <- round(species_i_rangepixels*0.05, 0) #rounds the calculated value to the nearest integer for easier indexing
  }
  
  backg_n
  
  
  # Sample background points, using bias specific to a target group
  ext <- ext(observationbias_species_i)
  # Generate background points using terra::spatSample()
  backg <- terra::spatSample(observationbias_species_i, 
                             size = backg_n, method = "random", 
                             na.rm = TRUE, xy = TRUE)
  backg
  
  colnames(backg)
  
  backg <- backg[, 1:2]  # Select only the first two columns
  colnames(backg) <- c("lon", "lat")
  
  # Make one sf for background
  backg_sf <- backg %>%
    as.data.frame(.) %>%
    st_as_sf(.,
             coords = c("lon", "lat"),
             crs = raster::crs(environmental_var_stack_i)) %>%
    mutate(p = 0) %>%
    cbind(., st_coordinates(.))
  
  head(backg_sf)
  
  # Make sf object with presence and background points
  species_i_presbackg_sf <- species_i_sf %>%
    st_as_sf(., crs = raster::crs(environmental_var_stack_i)) %>%
    mutate(p = 1) %>%
    cbind(., st_coordinates(.)) %>%
    rbind(backg_sf)
  
  head(species_i_presbackg_sf)
  tail(species_i_presbackg_sf)
  
  # Make sure all points have values for each environmental variable
  species_i_pb_extract <- raster::extract(environmental_var_stack_i,
                                          species_i_presbackg_sf) %>%
    as.data.frame(.)
  
  head(species_i_pb_extract)
  #View(species_i_pb_extract)
  
  # Omit NA row names
  species_i_omit_rownames <- row.names(species_i_pb_extract[is.na(species_i_pb_extract$forest) |
                                                              is.na(species_i_pb_extract$water)|
                                                              is.na(species_i_pb_extract$wetlands)|
                                                              is.na(species_i_pb_extract$annual.croplands)|
                                                              is.na(species_i_pb_extract$barren.lands)|
                                                              is.na(species_i_pb_extract$nativegrass)|
                                                              is.na(species_i_pb_extract$perennial.croplands)|
                                                              is.na(species_i_pb_extract$roads)|
                                                              is.na(species_i_pb_extract$settlements)|
                                                              is.na(species_i_pb_extract$tmax)|
                                                              
                                                              is.na(species_i_pb_extract$prec),]) 
  
  
  # Alternative approach to omitting row names
  #species_i_omit_rownames <- rownames(species_i_pb_extract[rowSums(is.na(species_i_pb_extract[
  #c("forest", "water", "wetlands", "annual.croplands", "barren.lands",
  #"nativegrass", "perennial.croplands", "roads", "settlements",
  #"tmax", "tmin", "prec")])) > 0, ])
  
  species_i_omit_rownames
  summary(species_i_omit_rownames)
  
  
  # Define species presence/background data
  species_i_presbackg_sf <- species_i_presbackg_sf %>%
    filter(!(row.names(.) %in% species_i_omit_rownames)) # Remove rows with NA values
  
  # Run spatial blocking to prepare data for cross-validation
  sb <- spatialBlock(speciesData = species_i_presbackg_sf %>%
                       filter(!(row.names(.) %in% species_i_omit_rownames)),
                     species = "p",  # Presence column (1 for presence, 0 for background)
                     rasterLayer = environmental_var_stack_i,
                     selection = "systematic",
                     rows = 10,
                     cols = 10,  # Define the number of rows and columns in the grid
                     k = 5,  # Number of folds for cross-validation
                     biomod2Format = TRUE)  # Format compatible with biomod2 package
  
  # Add fold ID to dataset
  species_i_presbackg_sf <- species_i_presbackg_sf %>%
    filter(!(row.names(.) %in% species_i_omit_rownames)) %>%
    mutate(fold = sb$foldID)
  
  # Ensure the fold assignments are properly distributed
  table(species_i_presbackg_sf$fold)  # Check the distribution of folds
  
  # Filter out rows with missing values
  species_i_pb_extract <- species_i_pb_extract %>%
    filter(!(row.names(.) %in% species_i_omit_rownames))
  
  # Initialize evaluation metrics
  species_i_eval_summary <- data.frame(fpr = c(), tpr = c(), fold = c())
  species_i_maxent_models <- list()  # List to store Maxent models
  species_i_px <- list()  # List to store habitat suitability predictions
  AUCs_i <- vector(mode = "numeric", length = 5)  # Store AUCs for each fold
  
  # Identify folds with no observations (e.g. large range, but small clustered points like Great Plains Toad)
  species_i_foldvector <- species_i_presbackg_sf %>%
    st_drop_geometry(.) %>%
    filter(p == 1) %>%
    group_by(fold) %>%
    summarize(total = n()) %>%
    pull(fold)
  
  # Loop through folds for cross-validation
  for (k in 1:5) {
    # Split data into training and testing sets based on fold
    trainSet <- which(sb$foldID != k)
    testSet <- which(sb$foldID == k)
    
    # Check if both training and testing sets have data
    if (length(trainSet) == 0 || length(testSet) == 0) {
      cat("No observations in fold", k, ", skipping this fold.\n")
      next  # Skip this fold if no observations are available
    }
    
    
    # Check column names in the species_i_presbackg_sf to verify the existence of the 'ID' column
    cat("Column names in species_i_presbackg_sf:", colnames(species_i_presbackg_sf), "\n")
    
    # Remove the 'ID' column from the environmental and presence-background data
    # If 'ID' column exists in species_i_presbackg_sf, it will be removed
    if("ID" %in% colnames(species_i_presbackg_sf)) {
      species_i_presbackg_sf_no_ID <- species_i_presbackg_sf %>%
        st_drop_geometry() %>%
        dplyr::select(-ID)  # Remove 'ID' column from the spatial data
    } else {
      cat("'ID' column not found in species_i_presbackg_sf\n")
      species_i_presbackg_sf_no_ID <- species_i_presbackg_sf  # Keep the data as is if no 'ID' column
    }
    
    # Remove the 'ID' column from the environmental data (assuming it's named 'ID' in species_i_pb_extract)
    species_i_pb_extract_no_ID <- species_i_pb_extract[, !colnames(species_i_pb_extract) %in% "ID"]
    species_i_pb_extract_no_ID
    
    # Subset the training and testing data
    trainData <- species_i_presbackg_sf[trainSet, ]
    testData <- species_i_presbackg_sf[testSet, ]
    trainEnv <-  species_i_pb_extract_no_ID[trainSet, ]
    testEnv <-  species_i_pb_extract_no_ID[testSet, ]
    
    
    # Now, fit the MaxEnt model using linear, quadratic, and hinge features
    
    # Fit Maxent model
    species_i_maxent_model <- maxent(
      x = trainEnv,  # Environmental variables for the training set
      p = trainData$p,  # Presence data for the training set
      a = trainData$background,  # Background data for the training set
      args = c("outputformat=cloglog", "betamultiplier=1", "maximumiterations=1000")  # Maxent model arguments
    )
    
    species_i_maxent_model
    
    
    # Store the fitted Maxent model
    species_i_maxent_models[[k]] <- species_i_maxent_model 
    
    # Get variable importance from the fitted Maxent model
    # Define output directory for variable importance (if not already defined)
    variable_importance_dir <- file.path("F:/Uillinois_data/analysis/habitat_suitability/variable_importance_mammals")
    dir.create(variable_importance_dir, recursive = TRUE, showWarnings = FALSE)
    
    # Extract variable importance for the species
    if (!is.null(species_i_maxent_model)) {
      
      # Extract variable contribution and permutation importance
      variable_importance <- species_i_maxent_model@results
      
      # Optionally: keep only relevant variable importance rows
      var_imp_rows <- grep("contribution$|permutation.importance$", rownames(variable_importance), value = TRUE)
      variable_importance_filtered <- variable_importance[var_imp_rows, , drop = FALSE]
      
      # Print for debugging
      cat("Variable importance for", scientific_name_i, ":\n")
      print(variable_importance_filtered)
      
      # Save as CSV with species name
      variable_importance_path <- file.path(variable_importance_dir, paste0("variable_importance_", scientific_name_i, ".csv"))
      write.csv(variable_importance_filtered, file = variable_importance_path, row.names = TRUE)
      
      cat("Variable importance saved for", scientific_name_i, "\n")
      
    } else {
      cat("No model found for", scientific_name_i, "â€” skipping variable importance export.\n")
    }
    
    
    # Predict habitat suitability for the test data
    species_i_px[[k]] <- predict(environmental_var_stack_i, 
                                 species_i_maxent_models[[k]], 
                                 ext = ext, 
                                 na.rm = TRUE,
                                 progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot( species_i_px[[k]], main = paste("Final Predicted climatic Habitat Suitability for Species", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir <- "F:/Uillinois_data/analysis/habitat_suitability/continuous_surface_predictions_mammals/"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir)) {
      dir.create(output_dir, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_i_px)) {
      if (!is.null(species_i_px[[k]])) {
        # Define the file path for each fold
        file_path <- paste0(output_dir, "habitat_suitability_species_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_i_px[[k]], filename = file_path, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    # Evualuate model
    
    species_predictions_avg <- list()
    species_i_eval <- list()  # Initialize list to store evaluation results
    species_i_eval_summary <- data.frame(
      fpr = numeric(),
      tpr = numeric(),
      mean_tpr = numeric(),
      sd_tpr = numeric(),
      se_tpr = numeric(),
      fold = integer()
    )
    
    # Initialize a vector to store AUC values
    auc_values <- numeric()
    
    
    if(k %in% species_i_foldvector){
      
      # Save evaluation for each fold
      species_i_eval[[k]] <- evaluate(p = species_i_presbackg_sf[testSet,] %>%
                                        st_drop_geometry(.) %>%
                                        filter(p == 1) %>%
                                        dplyr::select(-p, -fold),
                                      # p = presence, a = absence
                                      a = species_i_presbackg_sf[testSet,] %>%
                                        st_drop_geometry(.) %>%
                                        filter(p == 0) %>%
                                        dplyr::select(-p,-fold), 
                                      # model = maxent model
                                      model = species_i_maxent_models[[k]],
                                      # x = environmental variable raster stack
                                      x = environmental_var_stack_i)
      
      # Ensure the evaluation object is valid before proceeding
      if (!is.null(species_i_eval[[k]])) {
        
        # Extract FPR, TPR from model evaluation
        eval_df <- data.frame(
          fpr = species_i_eval[[k]]@FPR,
          tpr = species_i_eval[[k]]@TPR,  # Ensure TPR is included
          mean_tpr = mean(species_i_eval[[k]]@TPR, na.rm = TRUE),  # Compute mean TPR
          sd_tpr = sd(species_i_eval[[k]]@TPR, na.rm = TRUE),      # Compute SD of TPR
          se_tpr = sd(species_i_eval[[k]]@TPR, na.rm = TRUE) / sqrt(length(species_i_eval[[k]]@TPR)),  # Compute SE of TPR
          fold = k
        )
        
        # Step 1: Remove any existing NA rows in species_i_eval_summary
        species_i_eval_summary <- species_i_eval_summary %>%
          filter(!is.na(tpr))
        
        # Step 2: Ensure column names match
        eval_df <- eval_df %>%
          dplyr::select(all_of(colnames(species_i_eval_summary)))  # Keep column order consistent
        
        # Step 3: Append without introducing new NA values
        species_i_eval_summary <- bind_rows(species_i_eval_summary, eval_df)
        
        # Extract AUC value for the current fold and append it to the auc_values vector
        auc_values <- c(auc_values, species_i_eval[[k]]@auc)
        
        # Print number of test observations
        num_test_obs <- species_i_presbackg_sf[testSet, ] %>%
          st_drop_geometry() %>%
          filter(p == 1) %>%
          dplyr::select(-p, -fold) %>%
          nrow()
        
        print(paste("Number of test observations in fold", k, "is", num_test_obs))
        
      } else {
        cat(" Evaluation object is NULL for fold", k, "- Skipping.\n")
      }
    }
    
    avg_auc <- NA 
    
    # Calculate the average AUC for all folds (if auc_values contains any valid values)
    if (length(auc_values) > 0) {
      avg_auc <- mean(auc_values, na.rm = TRUE)
      cat("Average AUC across all folds for", scientific_name_i, ":", avg_auc, "\n")
      
      # Update the mean_auc column in modelPerformanceAllSpecies using the species name
      row_index <- which(modelPerformanceAllSpecies$scientific_name == scientific_name_i)
      
      if (length(row_index) == 1) {
        modelPerformanceAllSpecies$mean_auc[row_index] <- avg_auc
        cat("Average AUC saved for", scientific_name_i, "\n")
      } else {
        cat("Warning: Could not uniquely identify row for species", scientific_name_i, "\n")
      }
    } else {
      cat("No valid AUC values found for species", scientific_name_i, "\n")
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices <- which(!sapply(species_i_px, is.null))
    species_i_px_valid <- species_i_px[valid_indices]
    
    if (!is.na(avg_auc)) {
      auc_weights_valid <- (avg_auc - 0.5)^2
      # Proceed with weighting predictions
    } else {
      cat("Skipping AUC weighting for", scientific_name_i, "- avg_auc is NA\n")
      auc_weights_valid <- NA
    }
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    #auc_weights_valid <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid <- rep(auc_weights_valid, length(valid_indices))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_i_px_stack <- rast(species_i_px_valid)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_i_px_stack) == 1) {
      species_i_px_avg <- species_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_i_px_avg <- app(species_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_i_px_avg, main = paste("Average Habitat Suitability -", scientific_name_i))
    
    
    #species_predictions_avg <- list()
    species_predictions_avg[[scientific_name_i]] <- species_i_px_avg
    names(species_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir1 <- "F:/Uillinois_data/analysis/habitat_suitability/continuous_surface_predictions_mammals/average/"
    avg_suitability_path <- file.path(output_dir1, paste0("weighted_avg_habitat_suitability_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_i_px_avg, filename = avg_suitability_path, overwrite = TRUE)
      cat("Saved weighted average habitat suitability surface for", scientific_name_i, "\n")
      
      # Store in named list
      species_predictions_avg[[scientific_name_i]] <- species_i_px_avg
      
    } else {
      cat("species_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # --------------Obtaining optimal threshold---------------------------
    
    # ---------- Step 1: Extract thresholds (spec_sens) from each fold safely ----------
    fold_thresholds <- sapply(species_i_eval, function(eval_obj) {
      tryCatch({
        if (!is.null(eval_obj)) {
          dismo::threshold(eval_obj, 'spec_sens')
        } else {
          NA
        }
      }, error = function(e) NA)
    })
    
    # ---------- Step 2: Calculate valid weights ----------
    auc_weights <- (AUCs_i - 0.5)^2
    auc_weights[is.na(auc_weights)] <- 0  # zero out missing AUCs
    
    valid_folds <- which(!is.na(fold_thresholds) & auc_weights > 0)
    cat("Folds contributing to threshold calculation for", scientific_name_i, ":", paste(valid_folds, collapse = ", "), "\n")
    
    valid_thresholds <- fold_thresholds[valid_folds]
    valid_weights <- auc_weights[valid_folds]
    
    # ---------- Step 3: Compute the final threshold ----------
    if (length(valid_thresholds) > 0 && sum(valid_weights, na.rm = TRUE) > 0) {
      species_i_threshold <- weighted.mean(valid_thresholds, w = valid_weights, na.rm = TRUE)
    } else if (length(valid_thresholds) > 0) {
      species_i_threshold <- mean(valid_thresholds, na.rm = TRUE)
      cat("All weights were zero â€” used unweighted mean instead.\n")
    } else {
      species_i_threshold <- NA
      cat("No valid thresholds found â€” returning NA.\n")
    }
    
    cat("Final average threshold (spec_sens) for", scientific_name_i, ":", species_i_threshold, "\n")
    
    # ---------- Step 4: Save threshold to performance table ----------
    modelPerformanceAllSpecies$mean_threshold[modelPerformanceAllSpecies$scientific_name == scientific_name_i] <- species_i_threshold
    
    # Define file paths
    species_dir <- file.path("F:/Uillinois_data/analysis/habitat_suitability", gsub(" ", "_", scientific_name_i))
    dir.create(file.path(species_dir, "binary_mammals"), showWarnings = FALSE, recursive = TRUE)
    
    write.csv(modelPerformanceAllSpecies,
              file = file.path(species_dir, paste0(scientific_name_i, "_performance.csv")),
              row.names = FALSE)
    cat("Model performance table saved as CSV for", scientific_name_i, "\n")
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary <- species_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary, main = paste("Binary Suitability for", scientific_name_i))
      
      binary_path <- file.path(species_dir, "binary_mammals", paste0(scientific_name_i, "_mean_pixel_binary.tif"))
      writeRaster(
        species_i_binary,
        filename = binary_path,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    
    # ---------------------Conduct future projections------------------- 
    
    # Start by loading climatic variables
    
    # Access-CM2
    
    # A. ---------2011-2040-------------
    
    #------------2011-2040_ssp126--------------
    
    # load historical climate data
    DD0_2020s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_DD0.tif")
    EXT_2020s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_EXT.tif")
    PPT_at_2020s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_PPT_at.tif")
    PPT_sm_2020s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_PPT_sm.tif")
    PPT_wt_2020s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp126/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2020s_Access_ssp126 <- raster::stack( DD0_2020s_Access_ssp126, 
                                                                  EXT_2020s_Access_ssp126,
                                                                  PPT_at_2020s_Access_ssp126,
                                                                  PPT_sm_2020s_Access_ssp126,
                                                                  PPT_wt_2020s_Access_ssp126)
    environmental_var_stack_2020s_Access_ssp126
    
    plot(environmental_var_stack_2020s_Access_ssp126)
    
    
    names(environmental_var_stack_2020s_Access_ssp126) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    environmental_var_stack_2020s_Access_ssp126 <- terra::rast(environmental_var_stack_2020s_Access_ssp126)
    
    species_2020s_Access_ssp126_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2020s_Access_ssp126_i_px[[k]] <- predict(environmental_var_stack_2020s_Access_ssp126, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2020s_Access_ssp126_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2020 Access ssp126", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir2 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2020s/ssp126"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir2)) {
      dir.create(output_dir2, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2020s_Access_ssp126_i_px)) {
      if (!is.null(species_2020s_Access_ssp126_i_px[[k]])) {
        # Define the file path for each fold
        file_path2 <- paste0(output_dir2, "habitat_suitability_species_2020s_Access_ssp126_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2020s_Access_ssp126_i_px[[k]], filename = file_path2, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path2, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices1 <- which(!sapply(species_2020s_Access_ssp126_i_px, is.null))
    species_i_px_valid1 <- species_2020s_Access_ssp126_i_px[valid_indices1]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid1 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid1 <- rep(auc_weights_valid1, length(valid_indices1))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2020s_Access_ssp126_i_px_stack <- rast(species_i_px_valid1)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2020s_Access_ssp126_i_px_stack) == 1) {
      species_2020s_Access_ssp126_i_px_avg <- species_2020s_Access_ssp126_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2020s_Access_ssp126_i_px_avg <- app(species_2020s_Access_ssp126_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid1, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2020s_Access_ssp126_i_px_avg, main = paste("Average Habitat Suitability 2020s Access ssp126", scientific_name_i))
    
    
    species_2020s_Access_ssp126_predictions_avg <- list()
    species_2020s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp126_i_px_avg
    names(species_2020s_Access_ssp126_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir3 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2020s/ssp126/average/"
    avg_suitability_path3 <- file.path(output_dir3, paste0("weighted_avg_habitat_suitability_2020s_Access_ssp126_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2020s_Access_ssp126_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2020s_Access_ssp126_i_px_avg, filename = avg_suitability_path3, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2020s Access ssp126 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2020s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp126_i_px_avg
      
    } else {
      cat("species_2020s_Access_ssp126_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2020s_Access_ssp126 <- species_2020s_Access_ssp126_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2020s_Access_ssp126, main = paste("Binary Suitability 2020s Access ssp126 for", scientific_name_i))
      
      species_dir1 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2020s/ssp126", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir1, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary1 <- file.path(species_dir1, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2020s_Access_ssp126.tif"))
      writeRaster(
        species_i_binary_2020s_Access_ssp126,
        filename = binary1,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    
    # ---------2021-2040-ssp245-------------
    
    # load historical climate data
    DD0_2020s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_DD0.tif")
    EXT_2020s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_EXT.tif")
    PPT_at_2020s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_PPT_at.tif")
    PPT_sm_2020s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_PPT_sm.tif")
    PPT_wt_2020s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp245/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2020s_Access_ssp245 <- raster::stack( DD0_2020s_Access_ssp245, 
                                                                  EXT_2020s_Access_ssp245,
                                                                  PPT_at_2020s_Access_ssp245,
                                                                  PPT_sm_2020s_Access_ssp245,
                                                                  PPT_wt_2020s_Access_ssp245)
    environmental_var_stack_2020s_Access_ssp245
    
    plot(environmental_var_stack_2020s_Access_ssp245)
    
    
    names(environmental_var_stack_2020s_Access_ssp245) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2020s_Access_ssp245 <- terra::rast(environmental_var_stack_2020s_Access_ssp245)
    
    species_2020s_Access_ssp245_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2020s_Access_ssp245_i_px[[k]] <- predict(environmental_var_stack_2020s_Access_ssp245, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2020s_Access_ssp245_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2030 Access ssp245", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir22 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2020s/ssp245"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir22)) {
      dir.create(output_dir22, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2020s_Access_ssp245_i_px)) {
      if (!is.null(species_2020s_Access_ssp245_i_px[[k]])) {
        # Define the file path for each fold
        file_path22 <- paste0(output_dir22, "habitat_suitability_species_2020s_Access_ssp245_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2020s_Access_ssp245_i_px[[k]], filename = file_path22, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path22, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2020s_ssp245 <- which(!sapply(species_2020s_Access_ssp245_i_px, is.null))
    species_i_px_valid_2020s_ssp245 <- species_2020s_Access_ssp245_i_px[valid_indices_2020s_ssp245]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid2 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid2 <- rep(auc_weights_valid2, length(valid_indices_2020s_ssp245))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2020s_Access_ssp245_i_px_stack <- rast(species_i_px_valid_2020s_ssp245)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2020s_Access_ssp245_i_px_stack) == 1) {
      species_2020s_Access_ssp245_i_px_avg <- species_2020s_Access_ssp245_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2020s_Access_ssp245_i_px_avg <- app(species_2020s_Access_ssp245_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid2, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2020s_Access_ssp245_i_px_avg, main = paste("Average Habitat Suitability 2020s Access ssp245", scientific_name_i))
    
    
    species_2020s_Access_ssp245_predictions_avg <- list()
    species_2020s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp245_i_px_avg
    names(species_2020s_Access_ssp245_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir33 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2020s/ssp245/average/"
    avg_suitability_path33 <- file.path(output_dir33, paste0("weighted_avg_habitat_suitability_2020s_Access_ssp245_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2020s_Access_ssp245_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2020s_Access_ssp245_i_px_avg, filename = avg_suitability_path33, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2020s Access ssp245 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2020s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp245_i_px_avg
      
    } else {
      cat("species_2020s_Access_ssp245_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2020s_Access_ssp245 <- species_2020s_Access_ssp245_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2020s_Access_ssp245, main = paste("Binary Suitability 2020s Access ssp245 for", scientific_name_i))
      
      species_dir2 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2020s/ssp245/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir2, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path33 <- file.path(species_dir2, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2020s_Access_ssp245.tif"))
      writeRaster(
        species_i_binary_2020s_Access_ssp245,
        filename = binary_path33,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    # ---------2021-2040-ssp585-------------
    
    # load historical climate data
    DD0_2020s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_DD0.tif")
    EXT_2020s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_EXT.tif")
    PPT_at_2020s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_PPT_at.tif")
    PPT_sm_2020s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_PPT_sm.tif")
    PPT_wt_2020s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2011_2040_ssp585/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2020s_Access_ssp585 <- raster::stack( DD0_2020s_Access_ssp585, 
                                                                  EXT_2020s_Access_ssp585,
                                                                  PPT_at_2020s_Access_ssp585,
                                                                  PPT_sm_2020s_Access_ssp585,
                                                                  PPT_wt_2020s_Access_ssp585)
    environmental_var_stack_2020s_Access_ssp585
    
    plot(environmental_var_stack_2020s_Access_ssp585)
    
    
    names(environmental_var_stack_2020s_Access_ssp585) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2020s_Access_ssp585 <- terra::rast(environmental_var_stack_2020s_Access_ssp585)
    
    species_2020s_Access_ssp585_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2020s_Access_ssp585_i_px[[k]] <- predict(environmental_var_stack_2020s_Access_ssp585, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2020s_Access_ssp585_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2020 Access ssp585", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir222 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2020s/ssp585"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir222)) {
      dir.create(output_dir222, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2020s_Access_ssp585_i_px)) {
      if (!is.null(species_2020s_Access_ssp585_i_px[[k]])) {
        # Define the file path for each fold
        file_path222 <- paste0(output_dir222, "habitat_suitability_species_2020s_Access_ssp585_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2020s_Access_ssp585_i_px[[k]], filename = file_path222, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path222, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2020s_ssp585 <- which(!sapply(species_2020s_Access_ssp585_i_px, is.null))
    species_i_px_valid_2020s_ssp585 <- species_2020s_Access_ssp585_i_px[valid_indices_2020s_ssp585]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid3 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid3 <- rep(auc_weights_valid3, length(valid_indices_2020s_ssp585))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2020s_Access_ssp585_i_px_stack <- rast(species_i_px_valid_2020s_ssp585)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2020s_Access_ssp585_i_px_stack) == 1) {
      species_2020s_Access_ssp585_i_px_avg <- species_2020s_Access_ssp585_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2020s_Access_ssp585_i_px_avg <- app(species_2020s_Access_ssp585_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid3, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2020s_Access_ssp585_i_px_avg, main = paste("Average Habitat Suitability 2020s Access ssp585", scientific_name_i))
    
    
    species_2020s_Access_ssp585_predictions_avg <- list()
    species_2020s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp585_i_px_avg
    names(species_2020s_Access_ssp585_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir333 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2020s/ssp585/average/"
    avg_suitability_path333 <- file.path(output_dir333, paste0("weighted_avg_habitat_suitability_2020s_Access_ssp585_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2020s_Access_ssp585_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2020s_Access_ssp585_i_px_avg, filename = avg_suitability_path333, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2020s Access ssp585 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2020s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2020s_Access_ssp585_i_px_avg
      
    } else {
      cat("species_2020s_Access_ssp585_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2020s_Access_ssp585 <- species_2020s_Access_ssp585_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2020s_Access_ssp585, main = paste("Binary Suitability 2030s Access ssp585 for", scientific_name_i))
      
      species_dir3 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2020s/ssp585/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir3, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path333 <- file.path(species_dir3, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2020s_Access_ssp585.tif"))
      writeRaster(
        species_i_binary_2020s_Access_ssp585,
        filename = binary_path333,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    # B. ---------2041-2060-------------
    
    #------------2041-2060_ssp126--------------
    
    # load historical climate data
    DD0_2050s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_DD0.tif")
    EXT_2050s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_EXT.tif")
    PPT_at_2050s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_PPT_at.tif")
    PPT_sm_2050s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_PPT_sm.tif")
    PPT_wt_2050s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp126/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2050s_Access_ssp126 <- raster::stack( DD0_2050s_Access_ssp126, 
                                                                  EXT_2050s_Access_ssp126,
                                                                  PPT_at_2050s_Access_ssp126,
                                                                  PPT_sm_2050s_Access_ssp126,
                                                                  PPT_wt_2050s_Access_ssp126)
    environmental_var_stack_2050s_Access_ssp126
    
    plot(environmental_var_stack_2050s_Access_ssp126)
    
    
    names(environmental_var_stack_2050s_Access_ssp126) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2050s_Access_ssp126 <- terra::rast(environmental_var_stack_2050s_Access_ssp126)
    
    species_2050s_Access_ssp126_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2050s_Access_ssp126_i_px[[k]] <- predict(environmental_var_stack_2050s_Access_ssp126, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2050s_Access_ssp126_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2050 Access ssp126", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir4 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2050s/ssp126"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir4)) {
      dir.create(output_dir4, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2050s_Access_ssp126_i_px)) {
      if (!is.null(species_2050s_Access_ssp126_i_px[[k]])) {
        # Define the file path for each fold
        file_path4 <- paste0(output_dir4, "habitat_suitability_species_2050s_Access_ssp126_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2050s_Access_ssp126_i_px[[k]], filename = file_path4, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path4, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices4 <- which(!sapply(species_2050s_Access_ssp126_i_px, is.null))
    species_i_px_valid4 <- species_2050s_Access_ssp126_i_px[valid_indices4]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid4 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid4 <- rep(auc_weights_valid4, length(valid_indices4))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2050s_Access_ssp126_i_px_stack <- rast(species_i_px_valid4)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2050s_Access_ssp126_i_px_stack) == 1) {
      species_2050s_Access_ssp126_i_px_avg <- species_2050s_Access_ssp126_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2050s_Access_ssp126_i_px_avg <- app(species_2050s_Access_ssp126_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid4, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2050s_Access_ssp126_i_px_avg, main = paste("Average Habitat Suitability 2050s Access ssp126", scientific_name_i))
    
    
    #species_predictions_avg <- list()
    species_2050s_Access_ssp126_predictions_avg <- list()
    species_2050s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp126_i_px_avg
    names(species_2050s_Access_ssp126_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir4 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2050s/ssp126/average/"
    avg_suitability_path4 <- file.path(output_dir4, paste0("weighted_avg_habitat_suitability_2050s_Access_ssp126_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2050s_Access_ssp126_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2050s_Access_ssp126_i_px_avg, filename = avg_suitability_path4, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2050s Access ssp126 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2050s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp126_i_px_avg
      
    } else {
      cat("species_2050s_Access_ssp126_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2050s_Access_ssp126 <- species_2050s_Access_ssp126_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2050s_Access_ssp126, main = paste("Binary Suitability 2050s Access ssp126 for", scientific_name_i))
      
      species_dir31 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2050s/ssp126/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir31, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path4 <- file.path(species_dir31, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2050s_Access_ssp126.tif"))
      writeRaster(
        species_i_binary_2050s_Access_ssp126,
        filename = binary_path4,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    
    # ---------2041-2060-ssp245-------------
    
    # load historical climate data
    DD0_2050s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_DD0.tif")
    EXT_2050s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_EXT.tif")
    PPT_at_2050s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_PPT_at.tif")
    PPT_sm_2050s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_PPT_sm.tif")
    PPT_wt_2050s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp245/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2050s_Access_ssp245 <- raster::stack( DD0_2050s_Access_ssp245, 
                                                                  EXT_2050s_Access_ssp245,
                                                                  PPT_at_2050s_Access_ssp245,
                                                                  PPT_sm_2050s_Access_ssp245,
                                                                  PPT_wt_2050s_Access_ssp245)
    environmental_var_stack_2050s_Access_ssp245
    
    plot(environmental_var_stack_2050s_Access_ssp245)
    
    
    names(environmental_var_stack_2050s_Access_ssp245) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2050s_Access_ssp245 <- terra::rast(environmental_var_stack_2050s_Access_ssp245)
    
    species_2050s_Access_ssp245_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2050s_Access_ssp245_i_px[[k]] <- predict(environmental_var_stack_2050s_Access_ssp245, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2050s_Access_ssp245_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2050 Access ssp245", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir44 <- " F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2050s/ssp245"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir44)) {
      dir.create(output_dir44, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2050s_Access_ssp245_i_px)) {
      if (!is.null(species_2050s_Access_ssp245_i_px[[k]])) {
        # Define the file path for each fold
        file_path44 <- paste0(output_dir44, "habitat_suitability_species_2050s_Access_ssp245_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2050s_Access_ssp245_i_px[[k]], filename = file_path44, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path44, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2050s_ssp245 <- which(!sapply(species_2050s_Access_ssp245_i_px, is.null))
    species_i_px_valid_2050s_ssp245 <- species_2050s_Access_ssp245_i_px[valid_indices_2050s_ssp245]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid44 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid44 <- rep(auc_weights_valid44, length(valid_indices_2050s_ssp245))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2050s_Access_ssp245_i_px_stack <- rast(species_i_px_valid_2050s_ssp245)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2050s_Access_ssp245_i_px_stack) == 1) {
      species_2050s_Access_ssp245_i_px_avg <- species_2050s_Access_ssp245_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2050s_Access_ssp245_i_px_avg <- app(species_2050s_Access_ssp245_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid44, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2050s_Access_ssp245_i_px_avg, main = paste("Average Habitat Suitability 2050s Access ssp245", scientific_name_i))
    
    
    species_2050s_Access_ssp245_predictions_avg <- list()
    species_2050s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp245_i_px_avg
    names(species_2050s_Access_ssp245_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir444 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2050s/ssp245/average/"
    avg_suitability_path444 <- file.path(output_dir444, paste0("weighted_avg_habitat_suitability_2050s_Access_ssp245_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2050s_Access_ssp245_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2050s_Access_ssp245_i_px_avg, filename = avg_suitability_path444, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2050s Access ssp245 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2050s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp245_i_px_avg
      
    } else {
      cat("species_2050s_Access_ssp245_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2050s_Access_ssp245 <- species_2050s_Access_ssp245_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2050s_Access_ssp245, main = paste("Binary Suitability 2050s Access ssp245 for", scientific_name_i))
      
      species_dir4 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2050s/ssp245/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir4, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path444 <- file.path(species_dir4, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2050s_Access_ssp126.tif"))
      writeRaster(
        species_i_binary_2050s_Access_ssp245,
        filename = binary_path444,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    # ---------2041-2060-ssp585-------------
    
    # load historical climate data
    DD0_2050s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_DD0.tif")
    EXT_2050s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_EXT.tif")
    PPT_at_2050s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_PPT_at.tif")
    PPT_sm_2050s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_PPT_sm.tif")
    PPT_wt_2050s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2041_2070_ssp585/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2050s_Access_ssp585 <- raster::stack( DD0_2050s_Access_ssp585, 
                                                                  EXT_2050s_Access_ssp585,
                                                                  PPT_at_2050s_Access_ssp585,
                                                                  PPT_sm_2050s_Access_ssp585,
                                                                  PPT_wt_2050s_Access_ssp585)
    environmental_var_stack_2050s_Access_ssp585
    
    plot(environmental_var_stack_2050s_Access_ssp585)
    
    
    names(environmental_var_stack_2050s_Access_ssp585) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2050s_Access_ssp585 <- terra::rast(environmental_var_stack_2050s_Access_ssp585)
    
    species_2050s_Access_ssp585_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2050s_Access_ssp585_i_px[[k]] <- predict(environmental_var_stack_2050s_Access_ssp585, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2050s_Access_ssp585_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2030 Access ssp585", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir5 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2050s/ssp585"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir5)) {
      dir.create(output_dir5, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2050s_Access_ssp585_i_px)) {
      if (!is.null(species_2050s_Access_ssp585_i_px[[k]])) {
        # Define the file path for each fold
        file_path5 <- paste0(output_dir5, "habitat_suitability_species_2050s_Access_ssp585_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2050s_Access_ssp585_i_px[[k]], filename = file_path5, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path5, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2050s_ssp585 <- which(!sapply(species_2050s_Access_ssp585_i_px, is.null))
    species_i_px_valid_2050s_ssp585 <- species_2050s_Access_ssp585_i_px[valid_indices_2050s_ssp585]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid5 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid5 <- rep(auc_weights_valid5, length(valid_indices_2050s_ssp585))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2050s_Access_ssp585_i_px_stack <- rast(species_i_px_valid_2050s_ssp585)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2050s_Access_ssp585_i_px_stack) == 1) {
      species_2050s_Access_ssp585_i_px_avg <- species_2050s_Access_ssp585_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2050s_Access_ssp585_i_px_avg <- app(species_2050s_Access_ssp585_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid5, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2050s_Access_ssp585_i_px_avg, main = paste("Average Habitat Suitability 2050s Access ssp585", scientific_name_i))
    
    
    species_2050s_Access_ssp585_predictions_avg <- list()
    species_2050s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp585_i_px_avg
    names(species_2050s_Access_ssp585_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir55 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2050s/ssp585/average/"
    avg_suitability_path55 <- file.path(output_dir55, paste0("weighted_avg_habitat_suitability_2050s_Access_ssp585_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2050s_Access_ssp585_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2050s_Access_ssp585_i_px_avg, filename = avg_suitability_path55, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2050s Access ssp585 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2050s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2050s_Access_ssp585_i_px_avg
      
    } else {
      cat("species_2050s_Access_ssp585_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2050s_Access_ssp585 <- species_2050s_Access_ssp585_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2050s_Access_ssp585, main = paste("Binary Suitability 2050s Access ssp585 for", scientific_name_i))
      
      species_dir5 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2050s/ssp585/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir5, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path55 <- file.path(species_dir5, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2050s_Access_ssp585.tif"))
      writeRaster(
        species_i_binary_2050s_Access_ssp585,
        filename = binary_path55,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    # C. ---------2061-2080-------------
    
    #------------2061-2080_ssp126--------------
    
    # load historical climate data
    DD0_2070s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_DD0.tif")
    EXT_2070s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_EXT.tif")
    PPT_at_2070s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_PPT_at.tif")
    PPT_sm_2070s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_PPT_sm.tif")
    PPT_wt_2070s_Access_ssp126 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp126/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2070s_Access_ssp126 <- raster::stack( DD0_2070s_Access_ssp126, 
                                                                  EXT_2070s_Access_ssp126,
                                                                  PPT_at_2070s_Access_ssp126,
                                                                  PPT_sm_2070s_Access_ssp126,
                                                                  PPT_wt_2070s_Access_ssp126)
    environmental_var_stack_2070s_Access_ssp126
    
    plot(environmental_var_stack_2070s_Access_ssp126)
    
    
    names(environmental_var_stack_2070s_Access_ssp126) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    environmental_var_stack_2070s_Access_ssp126 <- terra::rast(environmental_var_stack_2070s_Access_ssp126)
    
    species_2070s_Access_ssp126_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2070s_Access_ssp126_i_px[[k]] <- predict(environmental_var_stack_2070s_Access_ssp126, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2070s_Access_ssp126_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2070 Access ssp126", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir6 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2070s/ssp126"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir6)) {
      dir.create(output_dir6, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2070s_Access_ssp126_i_px)) {
      if (!is.null(species_2070s_Access_ssp126_i_px[[k]])) {
        # Define the file path for each fold
        file_path6 <- paste0(output_dir6, "habitat_suitability_species_2070s_Access_ssp126_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2070s_Access_ssp126_i_px[[k]], filename = file_path6, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path6, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices6 <- which(!sapply(species_2070s_Access_ssp126_i_px, is.null))
    species_i_px_valid6 <- species_2070s_Access_ssp126_i_px[valid_indices6]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid6 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid6 <- rep(auc_weights_valid6, length(valid_indices6))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2070s_Access_ssp126_i_px_stack <- rast(species_i_px_valid6)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2070s_Access_ssp126_i_px_stack) == 1) {
      species_2070s_Access_ssp126_i_px_avg <- species_2070s_Access_ssp126_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2070s_Access_ssp126_i_px_avg <- app(species_2070s_Access_ssp126_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid6, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2070s_Access_ssp126_i_px_avg, main = paste("Average Habitat Suitability 2070s Access ssp126", scientific_name_i))
    
    
    species_2070s_Access_ssp126_predictions_avg <- list()
    species_2070s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp126_i_px_avg
    names(species_2070s_Access_ssp126_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir66 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2070s/ssp126/average/"
    avg_suitability_path66 <- file.path(output_dir66, paste0("weighted_avg_habitat_suitability_2070s_Access_ssp126_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2070s_Access_ssp126_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2070s_Access_ssp126_i_px_avg, filename = avg_suitability_path66, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2070s Access ssp126 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2070s_Access_ssp126_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp126_i_px_avg
      
    } else {
      cat("species_2070s_Access_ssp126_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2070s_Access_ssp126 <- species_2070s_Access_ssp126_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2070s_Access_ssp126, main = paste("Binary Suitability 2070s Access ssp126 for", scientific_name_i))
      
      species_dir6 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2070s/ssp126/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir6, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path66 <- file.path(species_dir6, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2070s_Access_ssp126.tif"))
      writeRaster(
        species_i_binary_2070s_Access_ssp126,
        filename = binary_path66,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    
    # ---------2061-2080-ssp245-------------
    
    # load historical climate data
    DD0_2070s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_DD0.tif")
    EXT_2070s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_EXT.tif")
    PPT_at_2070s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_PPT_at.tif")
    PPT_sm_2070s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_PPT_sm.tif")
    PPT_wt_2070s_Access_ssp245 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp245/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2070s_Access_ssp245 <- raster::stack( DD0_2070s_Access_ssp245, 
                                                                  EXT_2070s_Access_ssp245,
                                                                  PPT_at_2070s_Access_ssp245,
                                                                  PPT_sm_2070s_Access_ssp245,
                                                                  PPT_wt_2070s_Access_ssp245)
    environmental_var_stack_2070s_Access_ssp245
    
    plot(environmental_var_stack_2070s_Access_ssp245)
    
    
    names(environmental_var_stack_2070s_Access_ssp245) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2070s_Access_ssp245 <- terra::rast(environmental_var_stack_2070s_Access_ssp245)
    
    species_2070s_Access_ssp245_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2070s_Access_ssp245_i_px[[k]] <- predict(environmental_var_stack_2070s_Access_ssp245, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2070s_Access_ssp245_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2070 Access ssp245", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir7 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2070s/ssp245"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir7)) {
      dir.create(output_dir7, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2070s_Access_ssp245_i_px)) {
      if (!is.null(species_2070s_Access_ssp245_i_px[[k]])) {
        # Define the file path for each fold
        file_path7 <- paste0(output_dir7, "habitat_suitability_species_2070s_Access_ssp245_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2070s_Access_ssp245_i_px[[k]], filename = file_path7, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path7, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2070s_ssp245 <- which(!sapply(species_2070s_Access_ssp245_i_px, is.null))
    species_i_px_valid_2070s_ssp245 <- species_2070s_Access_ssp245_i_px[valid_indices_2070s_ssp245]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid77 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid77 <- rep(auc_weights_valid77, length(valid_indices_2070s_ssp245))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2070s_Access_ssp245_i_px_stack <- rast(species_i_px_valid_2070s_ssp245)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2070s_Access_ssp245_i_px_stack) == 1) {
      species_2070s_Access_ssp245_i_px_avg <- species_2070s_Access_ssp245_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2070s_Access_ssp245_i_px_avg <- app(species_2070s_Access_ssp245_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid77, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2070s_Access_ssp245_i_px_avg, main = paste("Average Habitat Suitability 2070s Access ssp245", scientific_name_i))
    
    
    species_2070s_Access_ssp245_predictions_avg <- list()
    species_2070s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp245_i_px_avg
    names(species_2070s_Access_ssp245_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir77 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2070s/ssp245/average/"
    avg_suitability_path77 <- file.path(output_dir77, paste0("weighted_avg_habitat_suitability_2070s_Access_ssp245_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2070s_Access_ssp245_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2070s_Access_ssp245_i_px_avg, filename = avg_suitability_path77, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2070s Access ssp245 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2070s_Access_ssp245_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp245_i_px_avg
      
    } else {
      cat("species_2070s_Access_ssp245_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2070s_Access_ssp245 <- species_2070s_Access_ssp245_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2070s_Access_ssp245, main = paste("Binary Suitability 2070s Access ssp245 for", scientific_name_i))
      
      species_dir7 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2070s/ssp245/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir7, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path77 <- file.path(species_dir7, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2070s_Access_ssp245.tif"))
      writeRaster(
        species_i_binary_2070s_Access_ssp245,
        filename = binary_path77,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
    
    # ---------2061-2080-ssp585-------------
    
    # load historical climate data
    DD0_2070s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_DD0.tif")
    EXT_2070s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_EXT.tif")
    PPT_at_2070s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_PPT_at.tif")
    PPT_sm_2070s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_PPT_sm.tif")
    PPT_wt_2070s_Access_ssp585 <- raster("F:/Uillinois_data/analysis/habitat_suitability/climate_data/2071_2100_ssp585/masked_PPT_wt.tif")
    
    
    # Stack all environmental rasters (raster stack)
    environmental_var_stack_2070s_Access_ssp585 <- raster::stack( DD0_2070s_Access_ssp585, 
                                                                  EXT_2070s_Access_ssp585,
                                                                  PPT_at_2070s_Access_ssp585,
                                                                  PPT_sm_2070s_Access_ssp585,
                                                                  PPT_wt_2070s_Access_ssp585)
    environmental_var_stack_2070s_Access_ssp585
    
    plot(environmental_var_stack_2070s_Access_ssp585)
    
    
    names(environmental_var_stack_2070s_Access_ssp585) <- c(
      "DD0",
      "EXT",
      "PPT_at",
      "PPT_sm",
      "PPT_wt"
    )
    
    
    environmental_var_stack_2070s_Access_ssp585 <- terra::rast(environmental_var_stack_2070s_Access_ssp585)
    
    species_2070s_Access_ssp585_i_px <- list()
    
    # Predict habitat suitability for the test data
    species_2070s_Access_ssp585_i_px[[k]] <- predict(environmental_var_stack_2070s_Access_ssp585, 
                                                     species_i_maxent_models[[k]], 
                                                     ext = ext, 
                                                     na.rm = TRUE,
                                                     progress = '') # suppresses the display of the progress bar during model prediction (an empty string means no progress bar will be shown).
    
    plot(species_2070s_Access_ssp585_i_px[[k]], main = paste("Predicted climatic Habitat Suitability 2070 Access ssp585", scientific_name_i))
    
    
    # Define the directory where the prediction files will be saved
    output_dir8 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2070s/ssp585"
    
    # Ensure the directory exists
    if (!dir.exists(output_dir8)) {
      dir.create(output_dir8, recursive = TRUE)  # Create the directory if it doesn't exist
    }
    
    for (k in seq_along(species_2070s_Access_ssp585_i_px)) {
      if (!is.null(species_2070s_Access_ssp585_i_px[[k]])) {
        # Define the file path for each fold
        file_path8 <- paste0(output_dir8, "habitat_suitability_species_2070s_Access_ssp585_", scientific_name_i, "_fold_", k, ".tif")
        
        # Save the raster as a TIFF file
        terra::writeRaster(species_2070s_Access_ssp585_i_px[[k]], filename = file_path8, overwrite = TRUE)
        
        # Print confirmation message
        cat("Saved:", file_path8, "\n")
      } else {
        cat("No valid prediction for fold", k, "\n")
      }
    }
    
    
    # Step 1: Keep only non-NULL raster predictions
    valid_indices_2070s_ssp585 <- which(!sapply(species_2070s_Access_ssp585_i_px, is.null))
    species_i_px_valid_2070s_ssp585 <- species_2070s_Access_ssp585_i_px[valid_indices_2070s_ssp585]
    
    # Step 2: Calculate AUC weights based on the average AUC across all folds
    # Adjust AUC weights using the average AUC value calculated earlier (avg_auc)
    auc_weights_valid8 <- (avg_auc - 0.5)^2  # Use avg_auc to compute weights
    auc_weights_valid8 <- rep(auc_weights_valid8, length(valid_indices_2070s_ssp585))  # Replicate for each valid prediction
    
    # Step 3: Stack the valid SpatRaster predictions
    species_2070s_Access_ssp585_i_px_stack <- rast(species_i_px_valid_2070s_ssp585)
    
    # Check if there is only one valid prediction layer
    if (nlyr(species_2070s_Access_ssp585_i_px_stack) == 1) {
      species_2070s_Access_ssp585_i_px_avg <- species_2070s_Access_ssp585_i_px_stack
      cat("Only one valid prediction layer â€” using it as the final habitat suitability surface.\n")
    } else {
      # Calculate the weighted average habitat suitability surface
      species_2070s_Access_ssp585_i_px_avg <- app(species_2070s_Access_ssp585_i_px_stack, fun = function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          return(weighted.mean(x, w = auc_weights_valid8, na.rm = TRUE))
        }
      })
      cat("Weighted average prediction surface computed for", scientific_name_i, "\n")
    }
    
    plot(species_2070s_Access_ssp585_i_px_avg, main = paste("Average Habitat Suitability 2070s Access ssp585", scientific_name_i))
    
    
    species_2070s_Access_ssp585_predictions_avg <- list()
    species_2070s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp585_i_px_avg
    names(species_2070s_Access_ssp585_predictions_avg)
    
    
    # Define output path for the average suitability raster
    output_dir88 <- "F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2070s/ssp585/average/"
    avg_suitability_path88 <- file.path(output_dir88, paste0("weighted_avg_habitat_suitability_2070s_Access_ssp585_", scientific_name_i, ".tif"))
    
    # Save the weighted average raster (SpatRaster object)
    if (exists("species_2070s_Access_ssp585_i_px_avg")) {
      
      # Save to disk
      terra::writeRaster(species_2070s_Access_ssp585_i_px_avg, filename = avg_suitability_path88, overwrite = TRUE)
      cat("Saved weighted average habitat suitability 2070s Access ssp585 for", scientific_name_i, "\n")
      
      # Store in named list
      species_2070s_Access_ssp585_predictions_avg[[scientific_name_i]] <- species_2070s_Access_ssp585_i_px_avg
      
    } else {
      cat("species_2070s_Access_ssp585_i_px_avg not found â€” skipping raster save for", scientific_name_i, "\n")
    }
    
    
    # ---------- Step 5: Create and Save Binary Suitability Raster ----------
    if (!is.na(species_i_threshold)) {
      species_i_binary_2070s_Access_ssp585 <- species_2070s_Access_ssp585_i_px_avg > species_i_threshold
      
      # plot
      plot(species_i_binary_2070s_Access_ssp585, main = paste("Binary Suitability 2070s Access ssp585 for", scientific_name_i))
      
      species_dir8 <- file.path("F:/Uillinois_data/analysis/habitat_suitability/mammals_future/2070s/ssp585/binary", gsub(" ", "_", scientific_name_i))
      dir.create(file.path(species_dir8, "binary"), showWarnings = FALSE, recursive = TRUE)
      binary_path88 <- file.path(species_dir8, "binary", paste0(scientific_name_i, "_mean_pixel_binary_2070s_Access_ssp585.tif"))
      writeRaster(
        species_i_binary_2070s_Access_ssp585,
        filename = binary_path88,
        overwrite = TRUE
      )
      
      cat("Binary habitat raster saved successfully for", scientific_name_i, "\n")
    } else {
      cat("Binary raster not created â€” threshold was NA for", scientific_name_i, "\n")
    }
    
  }}





